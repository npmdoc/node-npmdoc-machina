<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://machina-js.org/"

    >machina (v2.0.0)</a>
</h1>
<h4>A library for creating powerful and flexible finite state machines. Loosely inspired by Erlang/OTP's gen_fsm behavior.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina">module machina</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm">
            function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm
            <span class="apidocSignatureSpan">( options )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm">
            function <span class="apidocSignatureSpan">machina.</span>Fsm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.emit">
            function <span class="apidocSignatureSpan">machina.</span>emit
            <span class="apidocSignatureSpan">( eventName )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.off">
            function <span class="apidocSignatureSpan">machina.</span>off
            <span class="apidocSignatureSpan">( eventName, callback )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.on">
            function <span class="apidocSignatureSpan">machina.</span>on
            <span class="apidocSignatureSpan">( eventName, callback )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machina.</span>Fsm.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machina.</span>eventListeners</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machina.</span>machina_OLD</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machina.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.BehavioralFsm">module machina.BehavioralFsm</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.BehavioralFsm">
            function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm
            <span class="apidocSignatureSpan">( options )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.extend">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.</span>extend
            <span class="apidocSignatureSpan">( protoProps, staticProps )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.BehavioralFsm.prototype">module machina.BehavioralFsm.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.buildEventPayload">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>buildEventPayload
            <span class="apidocSignatureSpan">( client, data )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.clearQueue">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>clearQueue
            <span class="apidocSignatureSpan">( client, name )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.compositeState">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>compositeState
            <span class="apidocSignatureSpan">( client )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.configForState">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>configForState
            <span class="apidocSignatureSpan">( newState )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.deferAndTransition">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>deferAndTransition
            <span class="apidocSignatureSpan">( client, stateName )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.deferUntilTransition">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>deferUntilTransition
            <span class="apidocSignatureSpan">( client, stateName )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.emit">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>emit
            <span class="apidocSignatureSpan">( eventName )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.ensureClientMeta">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>ensureClientMeta
            <span class="apidocSignatureSpan">( client )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.getHandlerArgs">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>getHandlerArgs
            <span class="apidocSignatureSpan">( args, isCatchAll )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.getSystemHandlerArgs">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>getSystemHandlerArgs
            <span class="apidocSignatureSpan">( args, client )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.handle">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>handle
            <span class="apidocSignatureSpan">( client, input )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.initClient">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>initClient
            <span class="apidocSignatureSpan">( client )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.initialize">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>initialize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.off">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>off
            <span class="apidocSignatureSpan">( eventName, callback )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.on">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>on
            <span class="apidocSignatureSpan">( eventName, callback )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.processQueue">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>processQueue
            <span class="apidocSignatureSpan">( client )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.transition">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>transition
            <span class="apidocSignatureSpan">( client, newState )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.Fsm">module machina.Fsm</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.Fsm">
            function <span class="apidocSignatureSpan">machina.</span>Fsm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.extend">
            function <span class="apidocSignatureSpan">machina.Fsm.</span>extend
            <span class="apidocSignatureSpan">( protoProps, staticProps )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machina.Fsm.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.Fsm.prototype">module machina.Fsm.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.buildEventPayload">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>buildEventPayload
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.clearQueue">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>clearQueue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.constructor">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.deferUntilTransition">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>deferUntilTransition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.ensureClientArg">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>ensureClientArg
            <span class="apidocSignatureSpan">( args )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.ensureClientMeta">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>ensureClientMeta
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.getHandlerArgs">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>getHandlerArgs
            <span class="apidocSignatureSpan">( args, isCatchAll )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.getSystemHandlerArgs">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>getSystemHandlerArgs
            <span class="apidocSignatureSpan">( args, client )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.handle">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>handle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.initClient">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>initClient
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.processQueue">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>processQueue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.transition">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>transition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.machina_OLD">module machina.machina_OLD</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.machina_OLD.BehavioralFsm">
            function <span class="apidocSignatureSpan">machina.machina_OLD.</span>BehavioralFsm
            <span class="apidocSignatureSpan">( options )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.machina_OLD.Fsm">
            function <span class="apidocSignatureSpan">machina.machina_OLD.</span>Fsm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.machina_OLD.emit">
            function <span class="apidocSignatureSpan">machina.machina_OLD.</span>emit
            <span class="apidocSignatureSpan">( eventName )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.machina_OLD.off">
            function <span class="apidocSignatureSpan">machina.machina_OLD.</span>off
            <span class="apidocSignatureSpan">( eventName, callback )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.machina_OLD.on">
            function <span class="apidocSignatureSpan">machina.machina_OLD.</span>on
            <span class="apidocSignatureSpan">( eventName, callback )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machina.machina_OLD.</span>eventListeners</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machina.machina_OLD.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.utils">module machina.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.createUUID">
            function <span class="apidocSignatureSpan">machina.utils.</span>createUUID
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.extend">
            function <span class="apidocSignatureSpan">machina.utils.</span>extend
            <span class="apidocSignatureSpan">( protoProps, staticProps )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.getChildFsmInstance">
            function <span class="apidocSignatureSpan">machina.utils.</span>getChildFsmInstance
            <span class="apidocSignatureSpan">( config )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.getDefaultBehavioralOptions">
            function <span class="apidocSignatureSpan">machina.utils.</span>getDefaultBehavioralOptions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.getDefaultClientMeta">
            function <span class="apidocSignatureSpan">machina.utils.</span>getDefaultClientMeta
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.getDefaultOptions">
            function <span class="apidocSignatureSpan">machina.utils.</span>getDefaultOptions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.getLeaklessArgs">
            function <span class="apidocSignatureSpan">machina.utils.</span>getLeaklessArgs
            <span class="apidocSignatureSpan">( args, startIdx )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.listenToChild">
            function <span class="apidocSignatureSpan">machina.utils.</span>listenToChild
            <span class="apidocSignatureSpan">( fsm, child )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.makeFsmNamespace">
            function <span class="apidocSignatureSpan">machina.utils.</span>makeFsmNamespace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina" id="apidoc.module.machina">module machina</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm" id="apidoc.element.machina.BehavioralFsm">
        function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm
        <span class="apidocSignatureSpan">( options )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BehavioralFsm( options ) {
		_.extend( this, options );
		_.defaults( this, utils.getDefaultBehavioralOptions() );
		this.initialize.apply( this, arguments );
		topLevelEmitter.emit( events.NEW_FSM, this );
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Going Further
machina provides two constructor functions for creating an FSM: `machina.Fsm` and `machina.BehavioralFsm`:

#### The BehavioralFsm Constructor
`BehavioralFsm` is new to machina as of v1.0 (though the `Fsm` constructor now inherits from it). The `BehavioralFsm` constructor
 lets you create an FSM that defines *behavior* (hence the name) that you want applied to multiple, separate instances of *state
*. A `BehavioralFsm` instance does not (should not!) track state locally, on itself. For example, consider this scenario....where
 we get to twist our `vehicleSignal` FSM beyond reason: :smile:

```javascript
var vehicleSignal = new machina.<span class="apidocCodeKeywordSpan">BehavioralFsm</span>( {

initialize: function( options ) {
    // your setup code goes here...
},

namespace: &#x22;vehicle-signal&#x22;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm" id="apidoc.element.machina.Fsm">
        function <span class="apidocSignatureSpan">machina.</span>Fsm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Fsm = function () {
			BehavioralFsm.apply( this, arguments );
			this.ensureClientMeta();
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var machina = require(&#x27;machina&#x27;)(lodash);
var MyFsm = machina.Fsm.extend({ /* your stuff */});
```

Great, now that we know how to pull it in, let&#x27;s create an FSM to represent a vehicle traffic light at a pedestrian crosswalk
:

```javascript
var vehicleSignal = new machina.<span class="apidocCodeKeywordSpan">Fsm</span>( {

// the initialize method is called right after the FSM
// instance is constructed, giving you a place for any
// setup behavior, etc. It receives the same arguments
// (options) as the constructor function.
initialize: function( options ) {
    // your setup code goes here...
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.emit" id="apidoc.element.machina.emit">
        function <span class="apidocSignatureSpan">machina.</span>emit
        <span class="apidocSignatureSpan">( eventName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function ( eventName ) {
				var args = utils.getLeaklessArgs( arguments );
				if ( this.eventListeners[ &#x22;*&#x22; ] ) {
					_.each( this.eventListeners[ &#x22;*&#x22; ], function( callback ) {
						if ( !this.useSafeEmit ) {
							callback.apply( this, args );
						} else {
							try {
								callback.apply( this, args );
							} catch ( exception ) {
								<span class="apidocCodeCommentSpan">/* istanbul ignore else  */
</span>								if ( console &#x26;&#x26; typeof console.log !== &#x22;undefined&#x22; ) {
									console.log( exception.stack );
								}
							}
						}
					}, this );
				}
				if ( this.eventListeners[ eventName ] ) {
					_.each( this.eventListeners[ eventName ], function( callback ) {
						if ( !this.useSafeEmit ) {
							callback.apply( this, args.slice( 1 ) );
						} else {
							try {
								callback.apply( this, args.slice( 1 ) );
							} catch ( exception ) {
								/* istanbul ignore else  */
								if ( console &#x26;&#x26; typeof console.log !== &#x22;undefined&#x22; ) {
									console.log( exception.stack );
								}
							}
						}
					}, this );
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        green: {
// _onEnter is a special handler that is invoked
// immediately as the FSM transitions into the new state
_onEnter: function() {
    this.timer = setTimeout( function() {
        this.handle( &#x22;timeout&#x22; );
    }.bind( this ), 30000 );
    this.<span class="apidocCodeKeywordSpan">emit</span>( &#x22;vehicles&#x22;, { status: &#x22;GREEN&#x22; } );
},
// If all you need to do is transition to a new state
// inside an input handler, you can provide the string
// name of the state in place of the input handler function.
timeout: &#x22;green-interruptible&#x22;,
pedestrianWaiting: function() {
    this.deferUntilTransition( &#x22;green-interruptible&#x22; );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.off" id="apidoc.element.machina.off">
        function <span class="apidocSignatureSpan">machina.</span>off
        <span class="apidocSignatureSpan">( eventName, callback )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function ( eventName, callback ) {
				this.eventListeners = this.eventListeners || { &#x22;*&#x22;: [] };
				if ( !eventName ) {
					this.eventListeners = {};
				} else {
					if ( callback ) {
						this.eventListeners[ eventName ] = _.without( this.eventListeners[ eventName ], callback );
					} else {
						this.eventListeners[ eventName ] = [];
					}
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Unsubscribing can be done a couple of ways:

```javascript
//each listener gets a return value
var sub = trafficLight.on(&#x22;transition&#x22;, someCallback);
sub.<span class="apidocCodeKeywordSpan">off</span>(); // unsubscribes the handler

// OR, we can use the FSM&#x27;s prototype method -
// remove this specific subscription:
trafficLight.off(&#x22;transition&#x22;, someCallback);
// remove all transition subscribers
trafficLight.off(&#x22;transition&#x22;);
// remove ALL subscribers, period:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.on" id="apidoc.element.machina.on">
        function <span class="apidocSignatureSpan">machina.</span>on
        <span class="apidocSignatureSpan">( eventName, callback )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function ( eventName, callback ) {
				var self = this;
				self.eventListeners = self.eventListeners || { &#x22;*&#x22;: [] };
				if ( !self.eventListeners[ eventName ] ) {
					self.eventListeners[ eventName ] = [];
				}
				self.eventListeners[ eventName ].push( callback );
				return {
					eventName: eventName,
					callback: callback,
					off: function() {
						self.off( eventName, callback );
					}
				};
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### And You Mentioned Events?
machina FSMs are event emitters, and subscribing to them is pretty easy:

```javascript

// I&#x27;d like to know when the transition event occurs
trafficLight.<span class="apidocCodeKeywordSpan">on</span>(&#x22;transition&#x22;, function (data){
    console.log(&#x22;we just transitioned from &#x22; + data.fromState + &#x22; to &#x22; + data.toState);
});

// Or, maybe I want to know when ANY event occurs
trafficLight.on(&#x22;*&#x22;, function (eventName, data){
    console.log(&#x22;this thing happened:&#x22;, eventName);
});
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.BehavioralFsm" id="apidoc.module.machina.BehavioralFsm">module machina.BehavioralFsm</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.BehavioralFsm" id="apidoc.element.machina.BehavioralFsm.BehavioralFsm">
        function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm
        <span class="apidocSignatureSpan">( options )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BehavioralFsm( options ) {
		_.extend( this, options );
		_.defaults( this, utils.getDefaultBehavioralOptions() );
		this.initialize.apply( this, arguments );
		topLevelEmitter.emit( events.NEW_FSM, this );
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Going Further
machina provides two constructor functions for creating an FSM: `machina.Fsm` and `machina.BehavioralFsm`:

#### The BehavioralFsm Constructor
`BehavioralFsm` is new to machina as of v1.0 (though the `Fsm` constructor now inherits from it). The `BehavioralFsm` constructor
 lets you create an FSM that defines *behavior* (hence the name) that you want applied to multiple, separate instances of *state
*. A `BehavioralFsm` instance does not (should not!) track state locally, on itself. For example, consider this scenario....where
 we get to twist our `vehicleSignal` FSM beyond reason: :smile:

```javascript
var vehicleSignal = new machina.<span class="apidocCodeKeywordSpan">BehavioralFsm</span>( {

initialize: function( options ) {
    // your setup code goes here...
},

namespace: &#x22;vehicle-signal&#x22;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.extend" id="apidoc.element.machina.BehavioralFsm.extend">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.</span>extend
        <span class="apidocSignatureSpan">( protoProps, staticProps )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function ( protoProps, staticProps ) {
		var parent = this;
		var fsm; // placeholder for instance constructor
		var machObj = {}; // object used to hold initialState &#x26; states from prototype for instance-level merging
		var Ctor = function() {}; // placeholder ctor function used to insert level in prototype chain
	
		// The constructor function for the new subclass is either defined by you
		// (the &#x22;constructor&#x22; property in your `extend` definition), or defaulted
		// by us to simply call the parent&#x27;s constructor.
		if ( protoProps &#x26;&#x26; protoProps.hasOwnProperty( &#x22;constructor&#x22; ) ) {
			fsm = protoProps.constructor;
		} else {
			// The default machina constructor (when using inheritance) creates a
			// deep copy of the states/initialState values from the prototype and
			// extends them over the instance so that they&#x27;ll be instance-level.
			// If an options arg (args[0]) is passed in, a states or intialState
			// value will be preferred over any data pulled up from the prototype.
			fsm = function() {
				var args = slice.call( arguments, 0 );
				args[ 0 ] = args[ 0 ] || {};
				var blendedState;
				var instanceStates = args[ 0 ].states || {};
				blendedState = _.merge( _.cloneDeep( machObj ), { states: instanceStates } );
				blendedState.initialState = args[ 0 ].initialState || this.initialState;
				_.extend( args[ 0 ], blendedState );
				parent.apply( this, args );
			};
		}
	
		// Inherit class (static) properties from parent.
		_.merge( fsm, parent );
	
		// Set the prototype chain to inherit from `parent`, without calling
		// `parent`&#x27;s constructor function.
		Ctor.prototype = parent.prototype;
		fsm.prototype = new Ctor();
	
		// Add prototype properties (instance properties) to the subclass,
		// if supplied.
		if ( protoProps ) {
			_.extend( fsm.prototype, protoProps );
			_.merge( machObj, _.transform( protoProps, function( accum, val, key ) {
				if ( _machKeys.indexOf( key ) !== -1 ) {
					accum[ key ] = val;
				}
			} ) );
		}
	
		// Add static properties to the constructor function, if supplied.
		if ( staticProps ) {
			_.merge( fsm, staticProps );
		}
	
		// Correctly set child&#x27;s `prototype.constructor`.
		fsm.prototype.constructor = fsm;
	
		// Set a convenience property in case the parent&#x27;s prototype is needed later.
		fsm.__super__ = parent.prototype;
		return fsm;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Quick Example

First - you need to include it in your environment (browser, node, etc.):

```javascript
// If you&#x27;re not using an AMD loader, machina is available on the window
// Just make sure you have lodash loaded before machina
var MyFsm = machina.Fsm.<span class="apidocCodeKeywordSpan">extend</span>({ /* your stuff */});

// If you&#x27;re using an AMD loader:
require([&#x27;machina&#x27;], function(machina){
    return machina.Fsm.extend({ /* your stuff */});
});

// node.js/CommonJS:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.BehavioralFsm.prototype" id="apidoc.module.machina.BehavioralFsm.prototype">module machina.BehavioralFsm.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.buildEventPayload" id="apidoc.element.machina.BehavioralFsm.prototype.buildEventPayload">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>buildEventPayload
        <span class="apidocSignatureSpan">( client, data )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildEventPayload = function ( client, data ) {
			if ( _.isPlainObject( data ) ) {
				return _.extend( data, { client: client, namespace: this.namespace } );
			} else {
				return { client: client, data: data || null, namespace: this.namespace };
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
						delete this.pendingDelegations[ inputDef.ticket ];
					}
					handlerName = stateObj[ inputDef.inputType ] ? inputDef.inputType : &#x22;*&#x22;;
					isCatchAll = ( handlerName === &#x22;*&#x22; );
					handler = ( stateObj[ handlerName ] || this[ handlerName ] ) || this[ &#x22;*&#x22; ];
					action = clientMeta.state + &#x22;.&#x22; + handlerName;
					clientMeta.currentAction = action;
					var eventPayload = this.<span class="apidocCodeKeywordSpan">buildEventPayload</span>(
						client,
						{ inputType: inputDef.inputType, delegated: inputDef.delegated, ticket: inputDef.ticket }
					);
					if ( !handler ) {
						this.emit( events.NO_HANDLER, _.extend( { args: args }, eventPayload ) );
					} else {
						this.emit( events.HANDLING, eventPayload );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.clearQueue" id="apidoc.element.machina.BehavioralFsm.prototype.clearQueue">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>clearQueue
        <span class="apidocSignatureSpan">( client, name )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearQueue = function ( client, name ) {
			var clientMeta = this.ensureClientMeta( client );
			if ( !name ) {
				clientMeta.inputQueue = [];
			} else {
				var filter = function( evnt ) {
					return ( name ? evnt.untilState !== name : true );
				};
				clientMeta.inputQueue = _.filter( clientMeta.inputQueue, filter );
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.compositeState" id="apidoc.element.machina.BehavioralFsm.prototype.compositeState">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>compositeState
        <span class="apidocSignatureSpan">( client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compositeState = function ( client ) {
			var clientMeta = this.ensureClientMeta( client );
			var state = clientMeta.state;
			var child = this.states[state]._child &#x26;&#x26; this.states[state]._child.instance;
			if ( child ) {
				state += &#x22;.&#x22; + child.compositeState( client );
			}
			return state;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* When the parent FSM transitions to a new state, any child FSM from a previous state is ignored entirely (i.e. - events emitted
, or input bubbled, will *not* be handled in the parent). If the parent FSM transitions back to that state, it will resume listening
 to the child FSM, etc.
* As the parent state transitions into any of its states, it will tell the child FSM to handle a `_reset` input. This gives you
a hook to move the child FSM to the correct state before handling any further input. For example, you&#x27;ll notice our `pedestrianSignal
` FSM has a `_reset` input handler in the `dontwalk` state, which transitions the FSM to the `walking` state.

In v1.1.0, machina added the `compositeState()` method to the `BehavioralFsm` and `Fsm` prototypes. This means you can get the current
 state of the FSM hierarchy. For example:

```javascript
// calling compositeState on Fsm instances
console.log( crosswalk.<span class="apidocCodeKeywordSpan">compositeState</span>() ); // vehiclesEnabled.green

// calling compositeState on BehavioralFsm instances
// (you have to pass the client arg)
console.log( crosswalk.compositeState( fsmClient ) ); // pedestriansEnabled.walking
```

&#x3e;Caveats: This feature is very new to machina, so expect it to evolve a bit. I plan to fine-tune how events bubble in a hierarchy
 a bit more.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.configForState" id="apidoc.element.machina.BehavioralFsm.prototype.configForState">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>configForState
        <span class="apidocSignatureSpan">( newState )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function configForState( newState ) {
			var newStateObj = this.states[ newState ];
			var child;
			_.each( this.hierarchy, function( childListener, key ) {
				if ( childListener &#x26;&#x26; typeof childListener.off === &#x22;function&#x22; ) {
					childListener.off();
				}
			} );
	
			if ( newStateObj._child ) {
				newStateObj._child = utils.getChildFsmInstance( newStateObj._child );
				child = newStateObj._child &#x26;&#x26; newStateObj._child.instance;
				this.hierarchy[ child.namespace ] = utils.listenToChild( this, child );
			}
	
			return child;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			var handlerName;
			var handler;
			var isCatchAll = false;
			var child;
			var result;
			var action;
			if ( !clientMeta.inExitHandler ) {
				child = this.<span class="apidocCodeKeywordSpan">configForState</span>( currentState );
				if ( child &#x26;&#x26; !this.pendingDelegations[ inputDef.ticket ] &#x26;&#x26; !inputDef.bubbling ) {
					inputDef.ticket = ( inputDef.ticket || utils.createUUID() );
					inputDef.delegated = true;
					this.pendingDelegations[ inputDef.ticket ] = { delegatedTo: child.namespace };
					// WARNING - returning a value from `handle` on child FSMs is not really supported.
					// If you need to return values from child FSM input handlers, use events instead.
					result = child.handle.apply( child, args );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.deferAndTransition" id="apidoc.element.machina.BehavioralFsm.prototype.deferAndTransition">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>deferAndTransition
        <span class="apidocSignatureSpan">( client, stateName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deferAndTransition = function ( client, stateName ) {
			this.deferUntilTransition( client, stateName );
			this.transition( client, stateName );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.deferUntilTransition" id="apidoc.element.machina.BehavioralFsm.prototype.deferUntilTransition">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>deferUntilTransition
        <span class="apidocSignatureSpan">( client, stateName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deferUntilTransition = function ( client, stateName ) {
			var clientMeta = this.ensureClientMeta( client );
			if ( clientMeta.currentActionArgs ) {
				var queued = {
					type: events.NEXT_TRANSITION,
					untilState: stateName,
					args: clientMeta.currentActionArgs
				};
				clientMeta.inputQueue.push( queued );
				var eventPayload = this.buildEventPayload( client, {
					state: clientMeta.state,
					queuedArgs: queued
				} );
				this.emit( events.DEFERRED, eventPayload );
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// handled while in that state.
states: {
    uninitialized: {
        // Input handlers are usually functions. They can
        // take arguments, too (even though this one doesn&#x27;t)
        // The &#x22;*&#x22; handler is special (more on that in a bit)
        &#x22;*&#x22;: function() {
            this.<span class="apidocCodeKeywordSpan">deferUntilTransition</span>();
            // the `transition` method takes a target state (as a string)
            // and transitions to it. You should NEVER directly assign the
            // state property on an FSM. Also - while it&#x27;s certainly OK to
            // call `transition` externally, you usually end up with the
            // cleanest approach if you endeavor to transition *internally*
            // and just pass input to the FSM.
            this.transition( &#x22;green&#x22; );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.emit" id="apidoc.element.machina.BehavioralFsm.prototype.emit">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>emit
        <span class="apidocSignatureSpan">( eventName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function ( eventName ) {
				var args = utils.getLeaklessArgs( arguments );
				if ( this.eventListeners[ &#x22;*&#x22; ] ) {
					_.each( this.eventListeners[ &#x22;*&#x22; ], function( callback ) {
						if ( !this.useSafeEmit ) {
							callback.apply( this, args );
						} else {
							try {
								callback.apply( this, args );
							} catch ( exception ) {
								<span class="apidocCodeCommentSpan">/* istanbul ignore else  */
</span>								if ( console &#x26;&#x26; typeof console.log !== &#x22;undefined&#x22; ) {
									console.log( exception.stack );
								}
							}
						}
					}, this );
				}
				if ( this.eventListeners[ eventName ] ) {
					_.each( this.eventListeners[ eventName ], function( callback ) {
						if ( !this.useSafeEmit ) {
							callback.apply( this, args.slice( 1 ) );
						} else {
							try {
								callback.apply( this, args.slice( 1 ) );
							} catch ( exception ) {
								/* istanbul ignore else  */
								if ( console &#x26;&#x26; typeof console.log !== &#x22;undefined&#x22; ) {
									console.log( exception.stack );
								}
							}
						}
					}, this );
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        green: {
// _onEnter is a special handler that is invoked
// immediately as the FSM transitions into the new state
_onEnter: function() {
    this.timer = setTimeout( function() {
        this.handle( &#x22;timeout&#x22; );
    }.bind( this ), 30000 );
    this.<span class="apidocCodeKeywordSpan">emit</span>( &#x22;vehicles&#x22;, { status: &#x22;GREEN&#x22; } );
},
// If all you need to do is transition to a new state
// inside an input handler, you can provide the string
// name of the state in place of the input handler function.
timeout: &#x22;green-interruptible&#x22;,
pedestrianWaiting: function() {
    this.deferUntilTransition( &#x22;green-interruptible&#x22; );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.ensureClientMeta" id="apidoc.element.machina.BehavioralFsm.prototype.ensureClientMeta">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>ensureClientMeta
        <span class="apidocSignatureSpan">( client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ensureClientMeta( client ) {
			if ( typeof client !== &#x22;object&#x22; ) {
				throw new Error( &#x22;An FSM client must be an object.&#x22; );
			}
			client[ MACHINA_PROP ] = client[ MACHINA_PROP ] || {};
			if ( !client[ MACHINA_PROP ][ this.namespace ] ) {
				client[ MACHINA_PROP ][ this.namespace ] = _.cloneDeep( utils.getDefaultClientMeta() );
				this.initClient( client );
			}
			return client[ MACHINA_PROP ][ this.namespace ];
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	var BehavioralFsm = __webpack_require__( 6 );
	var utils = __webpack_require__( 3 );
	var _ = __webpack_require__( 1 );
	
	var Fsm = {
		constructor: function() {
			BehavioralFsm.apply( this, arguments );
			this.<span class="apidocCodeKeywordSpan">ensureClientMeta</span>();
		},
		initClient: function initClient() {
			var initialState = this.initialState;
			if ( !initialState ) {
				throw new Error( &#x22;You must specify an initial state for this FSM&#x22; );
			}
			if ( !this.states[ initialState ] ) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.getHandlerArgs" id="apidoc.element.machina.BehavioralFsm.prototype.getHandlerArgs">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>getHandlerArgs
        <span class="apidocSignatureSpan">( args, isCatchAll )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHandlerArgs = function ( args, isCatchAll ) {
			// index 0 is the client, index 1 is inputType
			// if we&#x27;re in a catch-all handler, input type needs to be included in the args
			// inputType might be an object, so we need to just get the inputType string if so
			var _args = args.slice( 0 );
			var input = _args[ 1 ];
			if ( typeof input === &#x22;object&#x22; ) {
				_args.splice( 1, 1, input.inputType );
			}
			return isCatchAll ?
				_args :
				[ _args[ 0 ] ].concat( _args.slice( 2 ) );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
						{ inputType: inputDef.inputType, delegated: inputDef.delegated, ticket: inputDef.ticket }
					);
					if ( !handler ) {
						this.emit( events.NO_HANDLER, _.extend( { args: args }, eventPayload ) );
					} else {
						this.emit( events.HANDLING, eventPayload );
						if ( typeof handler === &#x22;function&#x22; ) {
							result = handler.apply( this, this.<span class="apidocCodeKeywordSpan">getHandlerArgs</span>( args, isCatchAll ) );
						} else {
							result = handler;
							this.transition( client, handler );
						}
						this.emit( events.HANDLED, eventPayload );
					}
					clientMeta.priorAction = clientMeta.currentAction;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.getSystemHandlerArgs" id="apidoc.element.machina.BehavioralFsm.prototype.getSystemHandlerArgs">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>getSystemHandlerArgs
        <span class="apidocSignatureSpan">( args, client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSystemHandlerArgs = function ( args, client ) {
			return [ client ].concat( args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					var eventPayload = this.buildEventPayload( client, {
						fromState: clientMeta.priorState,
						action: clientMeta.currentAction,
						toState: newState
					} );
					this.emit( events.TRANSITION, eventPayload );
					if ( newStateObj._onEnter ) {
						newStateObj._onEnter.apply( this, this.<span class="apidocCodeKeywordSpan">getSystemHandlerArgs</span>( args, client ) );
						this.emit( events.TRANSITIONED, eventPayload );
					}
					if ( child ) {
						child.handle( client, &#x22;_reset&#x22; );
					}
	
					if ( clientMeta.targetReplayState === newState ) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.handle" id="apidoc.element.machina.BehavioralFsm.prototype.handle">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>handle
        <span class="apidocSignatureSpan">( client, input )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handle = function ( client, input ) {
			var inputDef = input;
			if ( typeof input === &#x22;undefined&#x22; ) {
				throw new Error( &#x22;The input argument passed to the FSM&#x27;s handle method is undefined. Did you forget to pass the input name?&#x22; );
			}
			if ( typeof input === &#x22;string&#x22; ) {
				inputDef = { inputType: input, delegated: false, ticket: undefined };
			}
			var clientMeta = this.ensureClientMeta( client );
			var args = utils.getLeaklessArgs( arguments );
			if ( typeof input !== &#x22;object&#x22; ) {
				args.splice( 1, 1, inputDef );
			}
			clientMeta.currentActionArgs = args.slice( 1 );
			var currentState = clientMeta.state;
			var stateObj = this.states[ currentState ];
			var handlerName;
			var handler;
			var isCatchAll = false;
			var child;
			var result;
			var action;
			if ( !clientMeta.inExitHandler ) {
				child = this.configForState( currentState );
				if ( child &#x26;&#x26; !this.pendingDelegations[ inputDef.ticket ] &#x26;&#x26; !inputDef.bubbling ) {
					inputDef.ticket = ( inputDef.ticket || utils.createUUID() );
					inputDef.delegated = true;
					this.pendingDelegations[ inputDef.ticket ] = { delegatedTo: child.namespace };
					// WARNING - returning a value from `handle` on child FSMs is not really supported.
					// If you need to return values from child FSM input handlers, use events instead.
					result = child.handle.apply( child, args );
				} else {
					if ( inputDef.ticket &#x26;&#x26; this.pendingDelegations[ inputDef.ticket ] ) {
						delete this.pendingDelegations[ inputDef.ticket ];
					}
					handlerName = stateObj[ inputDef.inputType ] ? inputDef.inputType : &#x22;*&#x22;;
					isCatchAll = ( handlerName === &#x22;*&#x22; );
					handler = ( stateObj[ handlerName ] || this[ handlerName ] ) || this[ &#x22;*&#x22; ];
					action = clientMeta.state + &#x22;.&#x22; + handlerName;
					clientMeta.currentAction = action;
					var eventPayload = this.buildEventPayload(
						client,
						{ inputType: inputDef.inputType, delegated: inputDef.delegated, ticket: inputDef.ticket }
					);
					if ( !handler ) {
						this.emit( events.NO_HANDLER, _.extend( { args: args }, eventPayload ) );
					} else {
						this.emit( events.HANDLING, eventPayload );
						if ( typeof handler === &#x22;function&#x22; ) {
							result = handler.apply( this, this.getHandlerArgs( args, isCatchAll ) );
						} else {
							result = handler;
							this.transition( client, handler );
						}
						this.emit( events.HANDLED, eventPayload );
					}
					clientMeta.priorAction = clientMeta.currentAction;
					clientMeta.currentAction = &#x22;&#x22;;
					clientMeta.currentActionArgs = undefined;
				}
			}
			return result;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
},
green: {
    // _onEnter is a special handler that is invoked
    // immediately as the FSM transitions into the new state
    _onEnter: function() {
        this.timer = setTimeout( function() {
            this.<span class="apidocCodeKeywordSpan">handle</span>( &#x22;timeout&#x22; );
        }.bind( this ), 30000 );
        this.emit( &#x22;vehicles&#x22;, { status: &#x22;GREEN&#x22; } );
    },
    // If all you need to do is transition to a new state
    // inside an input handler, you can provide the string
    // name of the state in place of the input handler function.
    timeout: &#x22;green-interruptible&#x22;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.initClient" id="apidoc.element.machina.BehavioralFsm.prototype.initClient">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>initClient
        <span class="apidocSignatureSpan">( client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initClient( client ) {
			var initialState = this.initialState;
			if ( !initialState ) {
				throw new Error( &#x22;You must specify an initial state for this FSM&#x22; );
			}
			if ( !this.states[ initialState ] ) {
				throw new Error( &#x22;The initial state specified does not exist in the states object.&#x22; );
			}
			this.transition( client, initialState );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			}
			this.transition( initialState );
		},
		ensureClientMeta: function ensureClientMeta() {
			if ( !this._stamped ) {
				this._stamped = true;
				_.defaults( this, _.cloneDeep( utils.getDefaultClientMeta() ) );
				this.<span class="apidocCodeKeywordSpan">initClient</span>();
			}
			return this;
		},
	
		ensureClientArg: function( args ) {
			var _args = args;
			// we need to test the args and verify that if a client arg has
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.initialize" id="apidoc.element.machina.BehavioralFsm.prototype.initialize">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>initialize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.off" id="apidoc.element.machina.BehavioralFsm.prototype.off">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>off
        <span class="apidocSignatureSpan">( eventName, callback )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function ( eventName, callback ) {
				this.eventListeners = this.eventListeners || { &#x22;*&#x22;: [] };
				if ( !eventName ) {
					this.eventListeners = {};
				} else {
					if ( callback ) {
						this.eventListeners[ eventName ] = _.without( this.eventListeners[ eventName ], callback );
					} else {
						this.eventListeners[ eventName ] = [];
					}
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Unsubscribing can be done a couple of ways:

```javascript
//each listener gets a return value
var sub = trafficLight.on(&#x22;transition&#x22;, someCallback);
sub.<span class="apidocCodeKeywordSpan">off</span>(); // unsubscribes the handler

// OR, we can use the FSM&#x27;s prototype method -
// remove this specific subscription:
trafficLight.off(&#x22;transition&#x22;, someCallback);
// remove all transition subscribers
trafficLight.off(&#x22;transition&#x22;);
// remove ALL subscribers, period:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.on" id="apidoc.element.machina.BehavioralFsm.prototype.on">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>on
        <span class="apidocSignatureSpan">( eventName, callback )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function ( eventName, callback ) {
				var self = this;
				self.eventListeners = self.eventListeners || { &#x22;*&#x22;: [] };
				if ( !self.eventListeners[ eventName ] ) {
					self.eventListeners[ eventName ] = [];
				}
				self.eventListeners[ eventName ].push( callback );
				return {
					eventName: eventName,
					callback: callback,
					off: function() {
						self.off( eventName, callback );
					}
				};
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### And You Mentioned Events?
machina FSMs are event emitters, and subscribing to them is pretty easy:

```javascript

// I&#x27;d like to know when the transition event occurs
trafficLight.<span class="apidocCodeKeywordSpan">on</span>(&#x22;transition&#x22;, function (data){
    console.log(&#x22;we just transitioned from &#x22; + data.fromState + &#x22; to &#x22; + data.toState);
});

// Or, maybe I want to know when ANY event occurs
trafficLight.on(&#x22;*&#x22;, function (eventName, data){
    console.log(&#x22;this thing happened:&#x22;, eventName);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.processQueue" id="apidoc.element.machina.BehavioralFsm.prototype.processQueue">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>processQueue
        <span class="apidocSignatureSpan">( client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processQueue = function ( client ) {
			var clientMeta = this.ensureClientMeta( client );
			var filterFn = function( item ) {
				return ( ( !item.untilState ) || ( item.untilState === clientMeta.state ) );
			};
			var toProcess = _.filter( clientMeta.inputQueue, filterFn );
			clientMeta.inputQueue = _.difference( clientMeta.inputQueue, toProcess );
			_.each( toProcess, function( item ) {
				this.handle.apply( this, [ client ].concat( item.args ) );
			}, this );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
						this.emit( events.TRANSITIONED, eventPayload );
					}
					if ( child ) {
						child.handle( client, &#x22;_reset&#x22; );
					}
	
					if ( clientMeta.targetReplayState === newState ) {
						this.<span class="apidocCodeKeywordSpan">processQueue</span>( client, events.NEXT_TRANSITION );
					}
					return;
				}
				this.emit( events.INVALID_STATE, this.buildEventPayload( client, {
					state: clientMeta.state,
					attemptedState: newState
				} ) );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.transition" id="apidoc.element.machina.BehavioralFsm.prototype.transition">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>transition
        <span class="apidocSignatureSpan">( client, newState )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transition = function ( client, newState ) {
			var clientMeta = this.ensureClientMeta( client );
			var curState = clientMeta.state;
			var curStateObj = this.states[ curState ];
			var newStateObj = this.states[ newState ];
			var child;
			var args = utils.getLeaklessArgs( arguments ).slice( 2 );
			if ( !clientMeta.inExitHandler &#x26;&#x26; newState !== curState ) {
				if ( newStateObj ) {
					child = this.configForState( newState );
					if ( curStateObj &#x26;&#x26; curStateObj._onExit ) {
						clientMeta.inExitHandler = true;
						curStateObj._onExit.call( this, client );
						clientMeta.inExitHandler = false;
					}
					clientMeta.targetReplayState = newState;
					clientMeta.priorState = curState;
					clientMeta.state = newState;
					var eventPayload = this.buildEventPayload( client, {
						fromState: clientMeta.priorState,
						action: clientMeta.currentAction,
						toState: newState
					} );
					this.emit( events.TRANSITION, eventPayload );
					if ( newStateObj._onEnter ) {
						newStateObj._onEnter.apply( this, this.getSystemHandlerArgs( args, client ) );
						this.emit( events.TRANSITIONED, eventPayload );
					}
					if ( child ) {
						child.handle( client, &#x22;_reset&#x22; );
					}
	
					if ( clientMeta.targetReplayState === newState ) {
						this.processQueue( client, events.NEXT_TRANSITION );
					}
					return;
				}
				this.emit( events.INVALID_STATE, this.buildEventPayload( client, {
					state: clientMeta.state,
					attemptedState: newState
				} ) );
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.deferUntilTransition();
        // the `transition` method takes a target state (as a string)
        // and transitions to it. You should NEVER directly assign the
        // state property on an FSM. Also - while it&#x27;s certainly OK to
        // call `transition` externally, you usually end up with the
        // cleanest approach if you endeavor to transition *internally*
        // and just pass input to the FSM.
        this.<span class="apidocCodeKeywordSpan">transition</span>( &#x22;green&#x22; );
    }
},
green: {
    // _onEnter is a special handler that is invoked
    // immediately as the FSM transitions into the new state
    _onEnter: function() {
        this.timer = setTimeout( function() {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.Fsm" id="apidoc.module.machina.Fsm">module machina.Fsm</a></h1>


    <h2>
        <a href="#apidoc.element.machina.Fsm.Fsm" id="apidoc.element.machina.Fsm.Fsm">
        function <span class="apidocSignatureSpan">machina.</span>Fsm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Fsm = function () {
			BehavioralFsm.apply( this, arguments );
			this.ensureClientMeta();
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var machina = require(&#x27;machina&#x27;)(lodash);
var MyFsm = machina.Fsm.extend({ /* your stuff */});
```

Great, now that we know how to pull it in, let&#x27;s create an FSM to represent a vehicle traffic light at a pedestrian crosswalk
:

```javascript
var vehicleSignal = new machina.<span class="apidocCodeKeywordSpan">Fsm</span>( {

// the initialize method is called right after the FSM
// instance is constructed, giving you a place for any
// setup behavior, etc. It receives the same arguments
// (options) as the constructor function.
initialize: function( options ) {
    // your setup code goes here...
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.extend" id="apidoc.element.machina.Fsm.extend">
        function <span class="apidocSignatureSpan">machina.Fsm.</span>extend
        <span class="apidocSignatureSpan">( protoProps, staticProps )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function ( protoProps, staticProps ) {
		var parent = this;
		var fsm; // placeholder for instance constructor
		var machObj = {}; // object used to hold initialState &#x26; states from prototype for instance-level merging
		var Ctor = function() {}; // placeholder ctor function used to insert level in prototype chain
	
		// The constructor function for the new subclass is either defined by you
		// (the &#x22;constructor&#x22; property in your `extend` definition), or defaulted
		// by us to simply call the parent&#x27;s constructor.
		if ( protoProps &#x26;&#x26; protoProps.hasOwnProperty( &#x22;constructor&#x22; ) ) {
			fsm = protoProps.constructor;
		} else {
			// The default machina constructor (when using inheritance) creates a
			// deep copy of the states/initialState values from the prototype and
			// extends them over the instance so that they&#x27;ll be instance-level.
			// If an options arg (args[0]) is passed in, a states or intialState
			// value will be preferred over any data pulled up from the prototype.
			fsm = function() {
				var args = slice.call( arguments, 0 );
				args[ 0 ] = args[ 0 ] || {};
				var blendedState;
				var instanceStates = args[ 0 ].states || {};
				blendedState = _.merge( _.cloneDeep( machObj ), { states: instanceStates } );
				blendedState.initialState = args[ 0 ].initialState || this.initialState;
				_.extend( args[ 0 ], blendedState );
				parent.apply( this, args );
			};
		}
	
		// Inherit class (static) properties from parent.
		_.merge( fsm, parent );
	
		// Set the prototype chain to inherit from `parent`, without calling
		// `parent`&#x27;s constructor function.
		Ctor.prototype = parent.prototype;
		fsm.prototype = new Ctor();
	
		// Add prototype properties (instance properties) to the subclass,
		// if supplied.
		if ( protoProps ) {
			_.extend( fsm.prototype, protoProps );
			_.merge( machObj, _.transform( protoProps, function( accum, val, key ) {
				if ( _machKeys.indexOf( key ) !== -1 ) {
					accum[ key ] = val;
				}
			} ) );
		}
	
		// Add static properties to the constructor function, if supplied.
		if ( staticProps ) {
			_.merge( fsm, staticProps );
		}
	
		// Correctly set child&#x27;s `prototype.constructor`.
		fsm.prototype.constructor = fsm;
	
		// Set a convenience property in case the parent&#x27;s prototype is needed later.
		fsm.__super__ = parent.prototype;
		return fsm;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Quick Example

First - you need to include it in your environment (browser, node, etc.):

```javascript
// If you&#x27;re not using an AMD loader, machina is available on the window
// Just make sure you have lodash loaded before machina
var MyFsm = machina.Fsm.<span class="apidocCodeKeywordSpan">extend</span>({ /* your stuff */});

// If you&#x27;re using an AMD loader:
require([&#x27;machina&#x27;], function(machina){
    return machina.Fsm.extend({ /* your stuff */});
});

// node.js/CommonJS:
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.Fsm.prototype" id="apidoc.module.machina.Fsm.prototype">module machina.Fsm.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.buildEventPayload" id="apidoc.element.machina.Fsm.prototype.buildEventPayload">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>buildEventPayload
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildEventPayload = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			var data = args[ 1 ];
			if ( _.isPlainObject( data ) ) {
				return _.extend( data, { namespace: this.namespace } );
			} else {
				return { data: data || null, namespace: this.namespace };
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
						delete this.pendingDelegations[ inputDef.ticket ];
					}
					handlerName = stateObj[ inputDef.inputType ] ? inputDef.inputType : &#x22;*&#x22;;
					isCatchAll = ( handlerName === &#x22;*&#x22; );
					handler = ( stateObj[ handlerName ] || this[ handlerName ] ) || this[ &#x22;*&#x22; ];
					action = clientMeta.state + &#x22;.&#x22; + handlerName;
					clientMeta.currentAction = action;
					var eventPayload = this.<span class="apidocCodeKeywordSpan">buildEventPayload</span>(
						client,
						{ inputType: inputDef.inputType, delegated: inputDef.delegated, ticket: inputDef.ticket }
					);
					if ( !handler ) {
						this.emit( events.NO_HANDLER, _.extend( { args: args }, eventPayload ) );
					} else {
						this.emit( events.HANDLING, eventPayload );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.clearQueue" id="apidoc.element.machina.Fsm.prototype.clearQueue">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>clearQueue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearQueue = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			return BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.constructor" id="apidoc.element.machina.Fsm.prototype.constructor">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function () {
			BehavioralFsm.apply( this, arguments );
			this.ensureClientMeta();
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.deferUntilTransition" id="apidoc.element.machina.Fsm.prototype.deferUntilTransition">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>deferUntilTransition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deferUntilTransition = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			return BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// handled while in that state.
states: {
    uninitialized: {
        // Input handlers are usually functions. They can
        // take arguments, too (even though this one doesn&#x27;t)
        // The &#x22;*&#x22; handler is special (more on that in a bit)
        &#x22;*&#x22;: function() {
            this.<span class="apidocCodeKeywordSpan">deferUntilTransition</span>();
            // the `transition` method takes a target state (as a string)
            // and transitions to it. You should NEVER directly assign the
            // state property on an FSM. Also - while it&#x27;s certainly OK to
            // call `transition` externally, you usually end up with the
            // cleanest approach if you endeavor to transition *internally*
            // and just pass input to the FSM.
            this.transition( &#x22;green&#x22; );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.ensureClientArg" id="apidoc.element.machina.Fsm.prototype.ensureClientArg">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>ensureClientArg
        <span class="apidocSignatureSpan">( args )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureClientArg = function ( args ) {
			var _args = args;
			// we need to test the args and verify that if a client arg has
			// been passed, it must be this FSM instance (this isn&#x27;t a behavioral FSM)
			if ( typeof _args[ 0 ] === &#x22;object&#x22; &#x26;&#x26; !( &#x22;inputType&#x22; in _args[ 0 ] ) &#x26;&#x26; _args[ 0 ] !== this ) {
				_args.splice( 0, 1, this );
			} else if ( typeof _args[ 0 ] !== &#x22;object&#x22; || ( typeof _args[ 0 ] === &#x22;object&#x22; &#x26;&#x26; ( &#x22;inputType&#x22; in _args[ 0 ] ) ) ) {
				_args.unshift( this );
			}
			return _args;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	
		getSystemHandlerArgs: function( args, client ) {
			return args;
		},
	
		// &#x22;classic&#x22; machina FSM do not emit the client property on events (which would be the FSM itself)
		buildEventPayload: function() {
			var args = this.<span class="apidocCodeKeywordSpan">ensureClientArg</span>( utils.getLeaklessArgs( arguments ) );
			var data = args[ 1 ];
			if ( _.isPlainObject( data ) ) {
				return _.extend( data, { namespace: this.namespace } );
			} else {
				return { data: data || null, namespace: this.namespace };
			}
		}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.ensureClientMeta" id="apidoc.element.machina.Fsm.prototype.ensureClientMeta">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>ensureClientMeta
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ensureClientMeta() {
			if ( !this._stamped ) {
				this._stamped = true;
				_.defaults( this, _.cloneDeep( utils.getDefaultClientMeta() ) );
				this.initClient();
			}
			return this;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	var BehavioralFsm = __webpack_require__( 6 );
	var utils = __webpack_require__( 3 );
	var _ = __webpack_require__( 1 );
	
	var Fsm = {
		constructor: function() {
			BehavioralFsm.apply( this, arguments );
			this.<span class="apidocCodeKeywordSpan">ensureClientMeta</span>();
		},
		initClient: function initClient() {
			var initialState = this.initialState;
			if ( !initialState ) {
				throw new Error( &#x22;You must specify an initial state for this FSM&#x22; );
			}
			if ( !this.states[ initialState ] ) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.getHandlerArgs" id="apidoc.element.machina.Fsm.prototype.getHandlerArgs">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>getHandlerArgs
        <span class="apidocSignatureSpan">( args, isCatchAll )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHandlerArgs = function ( args, isCatchAll ) {
			// index 0 is the client, index 1 is inputType
			// if we&#x27;re in a catch-all handler, input type needs to be included in the args
			// inputType might be an object, so we need to just get the inputType string if so
			var _args = args;
			var input = _args[ 1 ];
			if ( typeof inputType === &#x22;object&#x22; ) {
				_args.splice( 1, 1, input.inputType );
			}
			return isCatchAll ?
				_args.slice( 1 ) :
				_args.slice( 2 );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
						{ inputType: inputDef.inputType, delegated: inputDef.delegated, ticket: inputDef.ticket }
					);
					if ( !handler ) {
						this.emit( events.NO_HANDLER, _.extend( { args: args }, eventPayload ) );
					} else {
						this.emit( events.HANDLING, eventPayload );
						if ( typeof handler === &#x22;function&#x22; ) {
							result = handler.apply( this, this.<span class="apidocCodeKeywordSpan">getHandlerArgs</span>( args, isCatchAll ) );
						} else {
							result = handler;
							this.transition( client, handler );
						}
						this.emit( events.HANDLED, eventPayload );
					}
					clientMeta.priorAction = clientMeta.currentAction;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.getSystemHandlerArgs" id="apidoc.element.machina.Fsm.prototype.getSystemHandlerArgs">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>getSystemHandlerArgs
        <span class="apidocSignatureSpan">( args, client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSystemHandlerArgs = function ( args, client ) {
			return args;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					var eventPayload = this.buildEventPayload( client, {
						fromState: clientMeta.priorState,
						action: clientMeta.currentAction,
						toState: newState
					} );
					this.emit( events.TRANSITION, eventPayload );
					if ( newStateObj._onEnter ) {
						newStateObj._onEnter.apply( this, this.<span class="apidocCodeKeywordSpan">getSystemHandlerArgs</span>( args, client ) );
						this.emit( events.TRANSITIONED, eventPayload );
					}
					if ( child ) {
						child.handle( client, &#x22;_reset&#x22; );
					}
	
					if ( clientMeta.targetReplayState === newState ) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.handle" id="apidoc.element.machina.Fsm.prototype.handle">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>handle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handle = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			return BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
},
green: {
    // _onEnter is a special handler that is invoked
    // immediately as the FSM transitions into the new state
    _onEnter: function() {
        this.timer = setTimeout( function() {
            this.<span class="apidocCodeKeywordSpan">handle</span>( &#x22;timeout&#x22; );
        }.bind( this ), 30000 );
        this.emit( &#x22;vehicles&#x22;, { status: &#x22;GREEN&#x22; } );
    },
    // If all you need to do is transition to a new state
    // inside an input handler, you can provide the string
    // name of the state in place of the input handler function.
    timeout: &#x22;green-interruptible&#x22;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.initClient" id="apidoc.element.machina.Fsm.prototype.initClient">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>initClient
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initClient() {
			var initialState = this.initialState;
			if ( !initialState ) {
				throw new Error( &#x22;You must specify an initial state for this FSM&#x22; );
			}
			if ( !this.states[ initialState ] ) {
				throw new Error( &#x22;The initial state specified does not exist in the states object.&#x22; );
			}
			this.transition( initialState );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			}
			this.transition( initialState );
		},
		ensureClientMeta: function ensureClientMeta() {
			if ( !this._stamped ) {
				this._stamped = true;
				_.defaults( this, _.cloneDeep( utils.getDefaultClientMeta() ) );
				this.<span class="apidocCodeKeywordSpan">initClient</span>();
			}
			return this;
		},
	
		ensureClientArg: function( args ) {
			var _args = args;
			// we need to test the args and verify that if a client arg has
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.processQueue" id="apidoc.element.machina.Fsm.prototype.processQueue">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>processQueue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processQueue = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			return BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
						this.emit( events.TRANSITIONED, eventPayload );
					}
					if ( child ) {
						child.handle( client, &#x22;_reset&#x22; );
					}
	
					if ( clientMeta.targetReplayState === newState ) {
						this.<span class="apidocCodeKeywordSpan">processQueue</span>( client, events.NEXT_TRANSITION );
					}
					return;
				}
				this.emit( events.INVALID_STATE, this.buildEventPayload( client, {
					state: clientMeta.state,
					attemptedState: newState
				} ) );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.transition" id="apidoc.element.machina.Fsm.prototype.transition">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>transition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transition = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			return BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.deferUntilTransition();
        // the `transition` method takes a target state (as a string)
        // and transitions to it. You should NEVER directly assign the
        // state property on an FSM. Also - while it&#x27;s certainly OK to
        // call `transition` externally, you usually end up with the
        // cleanest approach if you endeavor to transition *internally*
        // and just pass input to the FSM.
        this.<span class="apidocCodeKeywordSpan">transition</span>( &#x22;green&#x22; );
    }
},
green: {
    // _onEnter is a special handler that is invoked
    // immediately as the FSM transitions into the new state
    _onEnter: function() {
        this.timer = setTimeout( function() {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.machina_OLD" id="apidoc.module.machina.machina_OLD">module machina.machina_OLD</a></h1>


    <h2>
        <a href="#apidoc.element.machina.machina_OLD.BehavioralFsm" id="apidoc.element.machina.machina_OLD.BehavioralFsm">
        function <span class="apidocSignatureSpan">machina.machina_OLD.</span>BehavioralFsm
        <span class="apidocSignatureSpan">( options )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BehavioralFsm( options ) {
	_.extend( this, options );
	_.defaults( this, getDefaultBehavioralOptions() );
	this.initialize.apply( this, arguments );
	machina.emit( NEW_FSM, this );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Going Further
machina provides two constructor functions for creating an FSM: `machina.Fsm` and `machina.BehavioralFsm`:

#### The BehavioralFsm Constructor
`BehavioralFsm` is new to machina as of v1.0 (though the `Fsm` constructor now inherits from it). The `BehavioralFsm` constructor
 lets you create an FSM that defines *behavior* (hence the name) that you want applied to multiple, separate instances of *state
*. A `BehavioralFsm` instance does not (should not!) track state locally, on itself. For example, consider this scenario....where
 we get to twist our `vehicleSignal` FSM beyond reason: :smile:

```javascript
var vehicleSignal = new machina.<span class="apidocCodeKeywordSpan">BehavioralFsm</span>( {

initialize: function( options ) {
    // your setup code goes here...
},

namespace: &#x22;vehicle-signal&#x22;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.machina_OLD.Fsm" id="apidoc.element.machina.machina_OLD.Fsm">
        function <span class="apidocSignatureSpan">machina.machina_OLD.</span>Fsm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Fsm = function () {
		BehavioralFsm.apply( this, arguments );
		this.ensureClientMeta();
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var machina = require(&#x27;machina&#x27;)(lodash);
var MyFsm = machina.Fsm.extend({ /* your stuff */});
```

Great, now that we know how to pull it in, let&#x27;s create an FSM to represent a vehicle traffic light at a pedestrian crosswalk
:

```javascript
var vehicleSignal = new machina.<span class="apidocCodeKeywordSpan">Fsm</span>( {

// the initialize method is called right after the FSM
// instance is constructed, giving you a place for any
// setup behavior, etc. It receives the same arguments
// (options) as the constructor function.
initialize: function( options ) {
    // your setup code goes here...
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.machina_OLD.emit" id="apidoc.element.machina.machina_OLD.emit">
        function <span class="apidocSignatureSpan">machina.machina_OLD.</span>emit
        <span class="apidocSignatureSpan">( eventName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function ( eventName ) {
		var args = getLeaklessArgs( arguments );
		if ( this.eventListeners[ &#x22;*&#x22; ] ) {
			_.each( this.eventListeners[ &#x22;*&#x22; ], function( callback ) {
				if ( !this.useSafeEmit ) {
					callback.apply( this, args );
				} else {
					try {
						callback.apply( this, args );
					} catch ( exception ) {
						<span class="apidocCodeCommentSpan">/* istanbul ignore else  */
</span>						if ( console &#x26;&#x26; typeof console.log !== &#x22;undefined&#x22; ) {
							console.log( exception.stack );
						}
					}
				}
			}, this );
		}
		if ( this.eventListeners[ eventName ] ) {
			_.each( this.eventListeners[ eventName ], function( callback ) {
				if ( !this.useSafeEmit ) {
					callback.apply( this, args.slice( 1 ) );
				} else {
					try {
						callback.apply( this, args.slice( 1 ) );
					} catch ( exception ) {
						/* istanbul ignore else  */
						if ( console &#x26;&#x26; typeof console.log !== &#x22;undefined&#x22; ) {
							console.log( exception.stack );
						}
					}
				}
			}, this );
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        green: {
// _onEnter is a special handler that is invoked
// immediately as the FSM transitions into the new state
_onEnter: function() {
    this.timer = setTimeout( function() {
        this.handle( &#x22;timeout&#x22; );
    }.bind( this ), 30000 );
    this.<span class="apidocCodeKeywordSpan">emit</span>( &#x22;vehicles&#x22;, { status: &#x22;GREEN&#x22; } );
},
// If all you need to do is transition to a new state
// inside an input handler, you can provide the string
// name of the state in place of the input handler function.
timeout: &#x22;green-interruptible&#x22;,
pedestrianWaiting: function() {
    this.deferUntilTransition( &#x22;green-interruptible&#x22; );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.machina_OLD.off" id="apidoc.element.machina.machina_OLD.off">
        function <span class="apidocSignatureSpan">machina.machina_OLD.</span>off
        <span class="apidocSignatureSpan">( eventName, callback )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function ( eventName, callback ) {
		this.eventListeners = this.eventListeners || { &#x22;*&#x22;: [] };
		if ( !eventName ) {
			this.eventListeners = {};
		} else {
			if ( callback ) {
				this.eventListeners[ eventName ] = _.without( this.eventListeners[ eventName ], callback );
			} else {
				this.eventListeners[ eventName ] = [];
			}
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Unsubscribing can be done a couple of ways:

```javascript
//each listener gets a return value
var sub = trafficLight.on(&#x22;transition&#x22;, someCallback);
sub.<span class="apidocCodeKeywordSpan">off</span>(); // unsubscribes the handler

// OR, we can use the FSM&#x27;s prototype method -
// remove this specific subscription:
trafficLight.off(&#x22;transition&#x22;, someCallback);
// remove all transition subscribers
trafficLight.off(&#x22;transition&#x22;);
// remove ALL subscribers, period:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.machina_OLD.on" id="apidoc.element.machina.machina_OLD.on">
        function <span class="apidocSignatureSpan">machina.machina_OLD.</span>on
        <span class="apidocSignatureSpan">( eventName, callback )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function ( eventName, callback ) {
		var self = this;
		self.eventListeners = self.eventListeners || { &#x22;*&#x22;: [] };
		if ( !self.eventListeners[ eventName ] ) {
			self.eventListeners[ eventName ] = [];
		}
		self.eventListeners[ eventName ].push( callback );
		return {
			eventName: eventName,
			callback: callback,
			off: function() {
				self.off( eventName, callback );
			}
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### And You Mentioned Events?
machina FSMs are event emitters, and subscribing to them is pretty easy:

```javascript

// I&#x27;d like to know when the transition event occurs
trafficLight.<span class="apidocCodeKeywordSpan">on</span>(&#x22;transition&#x22;, function (data){
    console.log(&#x22;we just transitioned from &#x22; + data.fromState + &#x22; to &#x22; + data.toState);
});

// Or, maybe I want to know when ANY event occurs
trafficLight.on(&#x22;*&#x22;, function (eventName, data){
    console.log(&#x22;this thing happened:&#x22;, eventName);
});
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.utils" id="apidoc.module.machina.utils">module machina.utils</a></h1>


    <h2>
        <a href="#apidoc.element.machina.utils.createUUID" id="apidoc.element.machina.utils.createUUID">
        function <span class="apidocSignatureSpan">machina.utils.</span>createUUID
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createUUID() {
		var s = [];
		var hexDigits = &#x22;0123456789abcdef&#x22;;
		for ( var i = 0; i &#x3c; 36; i++ ) {
			s[ i ] = hexDigits.substr( Math.floor( Math.random() * 0x10 ), 1 );
		}
		s[ 14 ] = &#x22;4&#x22;; // bits 12-15 of the time_hi_and_version field to 0010
		<span class="apidocCodeCommentSpan">/* jshint ignore:start */
</span>		s[ 19 ] = hexDigits.substr( ( s[ 19 ] &#x26; 0x3 ) | 0x8, 1 ); // bits 6-7 of the clock_seq_hi_and_reserved to 01
		/* jshint ignore:end */
		s[ 8 ] = s[ 13 ] = s[ 18 ] = s[ 23 ] = &#x22;-&#x22;;
		return s.join( &#x22;&#x22; );
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			var isCatchAll = false;
			var child;
			var result;
			var action;
			if ( !clientMeta.inExitHandler ) {
				child = this.configForState( currentState );
				if ( child &#x26;&#x26; !this.pendingDelegations[ inputDef.ticket ] &#x26;&#x26; !inputDef.bubbling ) {
					inputDef.ticket = ( inputDef.ticket || utils.<span class="apidocCodeKeywordSpan">createUUID</span>() );
					inputDef.delegated = true;
					this.pendingDelegations[ inputDef.ticket ] = { delegatedTo: child.namespace };
					// WARNING - returning a value from `handle` on child FSMs is not really supported.
					// If you need to return values from child FSM input handlers, use events instead.
					result = child.handle.apply( child, args );
				} else {
					if ( inputDef.ticket &#x26;&#x26; this.pendingDelegations[ inputDef.ticket ] ) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.utils.extend" id="apidoc.element.machina.utils.extend">
        function <span class="apidocSignatureSpan">machina.utils.</span>extend
        <span class="apidocSignatureSpan">( protoProps, staticProps )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function ( protoProps, staticProps ) {
		var parent = this;
		var fsm; // placeholder for instance constructor
		var machObj = {}; // object used to hold initialState &#x26; states from prototype for instance-level merging
		var Ctor = function() {}; // placeholder ctor function used to insert level in prototype chain
	
		// The constructor function for the new subclass is either defined by you
		// (the &#x22;constructor&#x22; property in your `extend` definition), or defaulted
		// by us to simply call the parent&#x27;s constructor.
		if ( protoProps &#x26;&#x26; protoProps.hasOwnProperty( &#x22;constructor&#x22; ) ) {
			fsm = protoProps.constructor;
		} else {
			// The default machina constructor (when using inheritance) creates a
			// deep copy of the states/initialState values from the prototype and
			// extends them over the instance so that they&#x27;ll be instance-level.
			// If an options arg (args[0]) is passed in, a states or intialState
			// value will be preferred over any data pulled up from the prototype.
			fsm = function() {
				var args = slice.call( arguments, 0 );
				args[ 0 ] = args[ 0 ] || {};
				var blendedState;
				var instanceStates = args[ 0 ].states || {};
				blendedState = _.merge( _.cloneDeep( machObj ), { states: instanceStates } );
				blendedState.initialState = args[ 0 ].initialState || this.initialState;
				_.extend( args[ 0 ], blendedState );
				parent.apply( this, args );
			};
		}
	
		// Inherit class (static) properties from parent.
		_.merge( fsm, parent );
	
		// Set the prototype chain to inherit from `parent`, without calling
		// `parent`&#x27;s constructor function.
		Ctor.prototype = parent.prototype;
		fsm.prototype = new Ctor();
	
		// Add prototype properties (instance properties) to the subclass,
		// if supplied.
		if ( protoProps ) {
			_.extend( fsm.prototype, protoProps );
			_.merge( machObj, _.transform( protoProps, function( accum, val, key ) {
				if ( _machKeys.indexOf( key ) !== -1 ) {
					accum[ key ] = val;
				}
			} ) );
		}
	
		// Add static properties to the constructor function, if supplied.
		if ( staticProps ) {
			_.merge( fsm, staticProps );
		}
	
		// Correctly set child&#x27;s `prototype.constructor`.
		fsm.prototype.constructor = fsm;
	
		// Set a convenience property in case the parent&#x27;s prototype is needed later.
		fsm.__super__ = parent.prototype;
		return fsm;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Quick Example

First - you need to include it in your environment (browser, node, etc.):

```javascript
// If you&#x27;re not using an AMD loader, machina is available on the window
// Just make sure you have lodash loaded before machina
var MyFsm = machina.Fsm.<span class="apidocCodeKeywordSpan">extend</span>({ /* your stuff */});

// If you&#x27;re using an AMD loader:
require([&#x27;machina&#x27;], function(machina){
    return machina.Fsm.extend({ /* your stuff */});
});

// node.js/CommonJS:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.utils.getChildFsmInstance" id="apidoc.element.machina.utils.getChildFsmInstance">
        function <span class="apidocSignatureSpan">machina.utils.</span>getChildFsmInstance
        <span class="apidocSignatureSpan">( config )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getChildFsmInstance( config ) {
		if ( !config ) {
			return;
		}
		var childFsmDefinition = {};
		if ( typeof config === &#x22;object&#x22; ) {
			// is this a config object with a factory?
			if ( config.factory ) {
				childFsmDefinition = config;
				childFsmDefinition.instance = childFsmDefinition.factory();
			} else {
				// assuming this is a machina instance
				childFsmDefinition.factory = function() {
					return config;
				};
			}
		} else if ( typeof config === &#x22;function&#x22; ) {
			childFsmDefinition.factory = config;
		}
		childFsmDefinition.instance = childFsmDefinition.factory();
		return childFsmDefinition;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			_.each( this.hierarchy, function( childListener, key ) {
				if ( childListener &#x26;&#x26; typeof childListener.off === &#x22;function&#x22; ) {
					childListener.off();
				}
			} );
	
			if ( newStateObj._child ) {
				newStateObj._child = utils.<span class="apidocCodeKeywordSpan">getChildFsmInstance</span>( newStateObj._child );
				child = newStateObj._child &#x26;&#x26; newStateObj._child.instance;
				this.hierarchy[ child.namespace ] = utils.listenToChild( this, child );
			}
	
			return child;
		},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.utils.getDefaultBehavioralOptions" id="apidoc.element.machina.utils.getDefaultBehavioralOptions">
        function <span class="apidocSignatureSpan">machina.utils.</span>getDefaultBehavioralOptions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultBehavioralOptions() {
		return {
			initialState: &#x22;uninitialized&#x22;,
			eventListeners: {
				&#x22;*&#x22;: []
			},
			states: {},
			namespace: makeFsmNamespace(),
			useSafeEmit: false,
			hierarchy: {},
			pendingDelegations: {}
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	var topLevelEmitter = emitter.instance;
	var events = __webpack_require__( 4 );
	
	var MACHINA_PROP = &#x22;__machina__&#x22;;
	
	function BehavioralFsm( options ) {
		_.extend( this, options );
		_.defaults( this, utils.<span class="apidocCodeKeywordSpan">getDefaultBehavioralOptions</span>() );
		this.initialize.apply( this, arguments );
		topLevelEmitter.emit( events.NEW_FSM, this );
	}
	
	_.extend( BehavioralFsm.prototype, {
		initialize: function() {},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.utils.getDefaultClientMeta" id="apidoc.element.machina.utils.getDefaultClientMeta">
        function <span class="apidocSignatureSpan">machina.utils.</span>getDefaultClientMeta
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultClientMeta() {
		return {
			inputQueue: [],
			targetReplayState: &#x22;&#x22;,
			state: undefined,
			priorState: undefined,
			priorAction: &#x22;&#x22;,
			currentAction: &#x22;&#x22;,
			currentActionArgs: undefined,
			inExitHandler: false
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				throw new Error( &#x22;The initial state specified does not exist in the states object.&#x22; );
			}
			this.transition( initialState );
		},
		ensureClientMeta: function ensureClientMeta() {
			if ( !this._stamped ) {
				this._stamped = true;
				_.defaults( this, _.cloneDeep( utils.<span class="apidocCodeKeywordSpan">getDefaultClientMeta</span>() ) );
				this.initClient();
			}
			return this;
		},
	
		ensureClientArg: function( args ) {
			var _args = args;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.utils.getDefaultOptions" id="apidoc.element.machina.utils.getDefaultOptions">
        function <span class="apidocSignatureSpan">machina.utils.</span>getDefaultOptions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultBehavioralOptions() {
		return {
			initialState: &#x22;uninitialized&#x22;,
			eventListeners: {
				&#x22;*&#x22;: []
			},
			states: {},
			namespace: makeFsmNamespace(),
			useSafeEmit: false,
			hierarchy: {},
			pendingDelegations: {}
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.utils.getLeaklessArgs" id="apidoc.element.machina.utils.getLeaklessArgs">
        function <span class="apidocSignatureSpan">machina.utils.</span>getLeaklessArgs
        <span class="apidocSignatureSpan">( args, startIdx )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLeaklessArgs( args, startIdx ) {
		var result = [];
		for ( var i = ( startIdx || 0 ); i &#x3c; args.length; i++ ) {
			result[ i ] = args[ i ];
		}
		return result;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	var utils = __webpack_require__( 3 );
	var _ = __webpack_require__( 1 );
	
	function getInstance() {
		return {
			emit: function( eventName ) {
				var args = utils.<span class="apidocCodeKeywordSpan">getLeaklessArgs</span>( arguments );
				if ( this.eventListeners[ &#x22;*&#x22; ] ) {
					_.each( this.eventListeners[ &#x22;*&#x22; ], function( callback ) {
						if ( !this.useSafeEmit ) {
							callback.apply( this, args );
						} else {
							try {
								callback.apply( this, args );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.utils.listenToChild" id="apidoc.element.machina.utils.listenToChild">
        function <span class="apidocSignatureSpan">machina.utils.</span>listenToChild
        <span class="apidocSignatureSpan">( fsm, child )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenToChild( fsm, child ) {
		// Need to investigate potential for discarded event
		// listener memory leak in long-running, deeply-nested hierarchies.
		return child.on( &#x22;*&#x22;, function( eventName, data ) {
			switch ( eventName ) {
				case events.NO_HANDLER:
					if ( !data.ticket &#x26;&#x26; !data.delegated &#x26;&#x26; data.namespace !== fsm.namespace ) {
						// Ok - we&#x27;re dealing w/ a child handling input that should bubble up
						data.args[ 1 ].bubbling = true;
					}
					// we do NOT bubble _reset inputs up to the parent
					if ( data.inputType !== &#x22;_reset&#x22; ) {
						fsm.handle.apply( fsm, data.args );
					}
					break;
				case events.HANDLING :
					var ticket = data.ticket;
					if ( ticket &#x26;&#x26; fsm.pendingDelegations[ ticket ] ) {
						delete fsm.pendingDelegations[ ticket ];
					}
					fsm.emit( eventName, data ); // possibly transform payload?
					break;
				default:
					fsm.emit( eventName, data ); // possibly transform payload?
					break;
			}
		} );
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					childListener.off();
				}
			} );
	
			if ( newStateObj._child ) {
				newStateObj._child = utils.getChildFsmInstance( newStateObj._child );
				child = newStateObj._child &#x26;&#x26; newStateObj._child.instance;
				this.hierarchy[ child.namespace ] = utils.<span class="apidocCodeKeywordSpan">listenToChild</span>( this, child );
			}
	
			return child;
		},
	
		ensureClientMeta: function ensureClientMeta( client ) {
			if ( typeof client !== &#x22;object&#x22; ) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.utils.makeFsmNamespace" id="apidoc.element.machina.utils.makeFsmNamespace">
        function <span class="apidocSignatureSpan">machina.utils.</span>makeFsmNamespace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeFsmNamespace = function () {
			return &#x22;fsm.&#x22; + machinaCount++;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function getDefaultBehavioralOptions() {
	return {
		initialState: &#x22;uninitialized&#x22;,
		eventListeners: {
			&#x22;*&#x22;: []
		},
		states: {},
		namespace: utils.<span class="apidocCodeKeywordSpan">makeFsmNamespace</span>(),
		useSafeEmit: false,
		hierarchy: {},
		pendingDelegations: {}
	};
}

function getDefaultClientMeta() {
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
