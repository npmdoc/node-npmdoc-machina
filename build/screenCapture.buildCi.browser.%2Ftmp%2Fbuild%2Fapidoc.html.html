<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://machina-js.org/">machina (v2.0.0)</a>
</h1>
<h4>A library for creating powerful and flexible finite state machines. Loosely inspired by Erlang/OTP's gen_fsm behavior.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina">module machina</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm">
            function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm
            <span class="apidocSignatureSpan">( options )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.extend">
            function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.extend
            <span class="apidocSignatureSpan">( protoProps, staticProps )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.buildEventPayload">
            function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.buildEventPayload
            <span class="apidocSignatureSpan">( client, data )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.clearQueue">
            function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.clearQueue
            <span class="apidocSignatureSpan">( client, name )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.compositeState">
            function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.compositeState
            <span class="apidocSignatureSpan">( client )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.configForState">
            function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.configForState
            <span class="apidocSignatureSpan">( newState )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.deferAndTransition">
            function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.deferAndTransition
            <span class="apidocSignatureSpan">( client, stateName )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.deferUntilTransition">
            function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.deferUntilTransition
            <span class="apidocSignatureSpan">( client, stateName )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.emit">
            function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.emit
            <span class="apidocSignatureSpan">( eventName )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.ensureClientMeta">
            function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.ensureClientMeta
            <span class="apidocSignatureSpan">( client )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.getHandlerArgs">
            function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.getHandlerArgs
            <span class="apidocSignatureSpan">( args, isCatchAll )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.getSystemHandlerArgs">
            function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.getSystemHandlerArgs
            <span class="apidocSignatureSpan">( args, client )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.handle">
            function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.handle
            <span class="apidocSignatureSpan">( client, input )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.initClient">
            function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.initClient
            <span class="apidocSignatureSpan">( client )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.initialize">
            function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.initialize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.off">
            function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.off
            <span class="apidocSignatureSpan">( eventName, callback )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.on">
            function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.on
            <span class="apidocSignatureSpan">( eventName, callback )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.processQueue">
            function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.processQueue
            <span class="apidocSignatureSpan">( client )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.transition">
            function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.transition
            <span class="apidocSignatureSpan">( client, newState )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm">
            function <span class="apidocSignatureSpan">machina.</span>Fsm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.buildEventPayload">
            function <span class="apidocSignatureSpan">machina.</span>Fsm.prototype.buildEventPayload
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.clearQueue">
            function <span class="apidocSignatureSpan">machina.</span>Fsm.prototype.clearQueue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.deferUntilTransition">
            function <span class="apidocSignatureSpan">machina.</span>Fsm.prototype.deferUntilTransition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.ensureClientArg">
            function <span class="apidocSignatureSpan">machina.</span>Fsm.prototype.ensureClientArg
            <span class="apidocSignatureSpan">( args )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.ensureClientMeta">
            function <span class="apidocSignatureSpan">machina.</span>Fsm.prototype.ensureClientMeta
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.getHandlerArgs">
            function <span class="apidocSignatureSpan">machina.</span>Fsm.prototype.getHandlerArgs
            <span class="apidocSignatureSpan">( args, isCatchAll )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.getSystemHandlerArgs">
            function <span class="apidocSignatureSpan">machina.</span>Fsm.prototype.getSystemHandlerArgs
            <span class="apidocSignatureSpan">( args, client )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.handle">
            function <span class="apidocSignatureSpan">machina.</span>Fsm.prototype.handle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.initClient">
            function <span class="apidocSignatureSpan">machina.</span>Fsm.prototype.initClient
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.processQueue">
            function <span class="apidocSignatureSpan">machina.</span>Fsm.prototype.processQueue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.transition">
            function <span class="apidocSignatureSpan">machina.</span>Fsm.prototype.transition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.emit">
            function <span class="apidocSignatureSpan">machina.</span>emit
            <span class="apidocSignatureSpan">( eventName )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.off">
            function <span class="apidocSignatureSpan">machina.</span>off
            <span class="apidocSignatureSpan">( eventName, callback )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.on">
            function <span class="apidocSignatureSpan">machina.</span>on
            <span class="apidocSignatureSpan">( eventName, callback )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.createUUID">
            function <span class="apidocSignatureSpan">machina.</span>utils.createUUID
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.getChildFsmInstance">
            function <span class="apidocSignatureSpan">machina.</span>utils.getChildFsmInstance
            <span class="apidocSignatureSpan">( config )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.getDefaultBehavioralOptions">
            function <span class="apidocSignatureSpan">machina.</span>utils.getDefaultBehavioralOptions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.getDefaultClientMeta">
            function <span class="apidocSignatureSpan">machina.</span>utils.getDefaultClientMeta
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.getLeaklessArgs">
            function <span class="apidocSignatureSpan">machina.</span>utils.getLeaklessArgs
            <span class="apidocSignatureSpan">( args, startIdx )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.listenToChild">
            function <span class="apidocSignatureSpan">machina.</span>utils.listenToChild
            <span class="apidocSignatureSpan">( fsm, child )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.makeFsmNamespace">
            function <span class="apidocSignatureSpan">machina.</span>utils.makeFsmNamespace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machina.</span>Fsm.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machina.</span>eventListeners</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machina.</span>machina_OLD</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machina.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.BehavioralFsm">module machina.BehavioralFsm</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.BehavioralFsm">
            function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm
            <span class="apidocSignatureSpan">( options )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.extend">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.</span>extend
            <span class="apidocSignatureSpan">( protoProps, staticProps )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.BehavioralFsm.extend">module machina.BehavioralFsm.extend</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.extend.extend">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.</span>extend
            <span class="apidocSignatureSpan">( protoProps, staticProps )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.BehavioralFsm.prototype">module machina.BehavioralFsm.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.buildEventPayload">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>buildEventPayload
            <span class="apidocSignatureSpan">( client, data )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.clearQueue">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>clearQueue
            <span class="apidocSignatureSpan">( client, name )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.compositeState">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>compositeState
            <span class="apidocSignatureSpan">( client )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.configForState">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>configForState
            <span class="apidocSignatureSpan">( newState )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.deferAndTransition">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>deferAndTransition
            <span class="apidocSignatureSpan">( client, stateName )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.deferUntilTransition">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>deferUntilTransition
            <span class="apidocSignatureSpan">( client, stateName )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.emit">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>emit
            <span class="apidocSignatureSpan">( eventName )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.ensureClientMeta">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>ensureClientMeta
            <span class="apidocSignatureSpan">( client )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.getHandlerArgs">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>getHandlerArgs
            <span class="apidocSignatureSpan">( args, isCatchAll )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.getSystemHandlerArgs">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>getSystemHandlerArgs
            <span class="apidocSignatureSpan">( args, client )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.handle">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>handle
            <span class="apidocSignatureSpan">( client, input )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.initClient">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>initClient
            <span class="apidocSignatureSpan">( client )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.initialize">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>initialize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.off">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>off
            <span class="apidocSignatureSpan">( eventName, callback )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.on">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>on
            <span class="apidocSignatureSpan">( eventName, callback )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.processQueue">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>processQueue
            <span class="apidocSignatureSpan">( client )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.transition">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>transition
            <span class="apidocSignatureSpan">( client, newState )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.BehavioralFsm.prototype.buildEventPayload">module machina.BehavioralFsm.prototype.buildEventPayload</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.buildEventPayload.buildEventPayload">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>buildEventPayload
            <span class="apidocSignatureSpan">( client, data )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.BehavioralFsm.prototype.clearQueue">module machina.BehavioralFsm.prototype.clearQueue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.clearQueue.clearQueue">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>clearQueue
            <span class="apidocSignatureSpan">( client, name )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.BehavioralFsm.prototype.compositeState">module machina.BehavioralFsm.prototype.compositeState</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.compositeState.compositeState">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>compositeState
            <span class="apidocSignatureSpan">( client )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.BehavioralFsm.prototype.configForState">module machina.BehavioralFsm.prototype.configForState</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.configForState.configForState">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>configForState
            <span class="apidocSignatureSpan">( newState )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.BehavioralFsm.prototype.deferAndTransition">module machina.BehavioralFsm.prototype.deferAndTransition</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.deferAndTransition.deferAndTransition">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>deferAndTransition
            <span class="apidocSignatureSpan">( client, stateName )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.BehavioralFsm.prototype.deferUntilTransition">module machina.BehavioralFsm.prototype.deferUntilTransition</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.deferUntilTransition.deferUntilTransition">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>deferUntilTransition
            <span class="apidocSignatureSpan">( client, stateName )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.BehavioralFsm.prototype.emit">module machina.BehavioralFsm.prototype.emit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.emit.emit">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>emit
            <span class="apidocSignatureSpan">( eventName )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.BehavioralFsm.prototype.ensureClientMeta">module machina.BehavioralFsm.prototype.ensureClientMeta</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.ensureClientMeta.ensureClientMeta">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>ensureClientMeta
            <span class="apidocSignatureSpan">( client )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.BehavioralFsm.prototype.getHandlerArgs">module machina.BehavioralFsm.prototype.getHandlerArgs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.getHandlerArgs.getHandlerArgs">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>getHandlerArgs
            <span class="apidocSignatureSpan">( args, isCatchAll )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.BehavioralFsm.prototype.getSystemHandlerArgs">module machina.BehavioralFsm.prototype.getSystemHandlerArgs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.getSystemHandlerArgs.getSystemHandlerArgs">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>getSystemHandlerArgs
            <span class="apidocSignatureSpan">( args, client )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.BehavioralFsm.prototype.handle">module machina.BehavioralFsm.prototype.handle</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.handle.handle">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>handle
            <span class="apidocSignatureSpan">( client, input )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.BehavioralFsm.prototype.initClient">module machina.BehavioralFsm.prototype.initClient</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.initClient.initClient">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>initClient
            <span class="apidocSignatureSpan">( client )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.BehavioralFsm.prototype.initialize">module machina.BehavioralFsm.prototype.initialize</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.initialize.initialize">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>initialize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.BehavioralFsm.prototype.off">module machina.BehavioralFsm.prototype.off</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.off.off">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>off
            <span class="apidocSignatureSpan">( eventName, callback )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.BehavioralFsm.prototype.on">module machina.BehavioralFsm.prototype.on</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.on.on">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>on
            <span class="apidocSignatureSpan">( eventName, callback )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.BehavioralFsm.prototype.processQueue">module machina.BehavioralFsm.prototype.processQueue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.processQueue.processQueue">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>processQueue
            <span class="apidocSignatureSpan">( client )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.BehavioralFsm.prototype.transition">module machina.BehavioralFsm.prototype.transition</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.BehavioralFsm.prototype.transition.transition">
            function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>transition
            <span class="apidocSignatureSpan">( client, newState )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.Fsm">module machina.Fsm</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.Fsm">
            function <span class="apidocSignatureSpan">machina.</span>Fsm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.extend">
            function <span class="apidocSignatureSpan">machina.Fsm.</span>extend
            <span class="apidocSignatureSpan">( protoProps, staticProps )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machina.Fsm.</span>__super__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.Fsm.prototype">module machina.Fsm.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.buildEventPayload">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>buildEventPayload
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.clearQueue">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>clearQueue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.constructor">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.deferUntilTransition">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>deferUntilTransition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.ensureClientArg">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>ensureClientArg
            <span class="apidocSignatureSpan">( args )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.ensureClientMeta">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>ensureClientMeta
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.getHandlerArgs">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>getHandlerArgs
            <span class="apidocSignatureSpan">( args, isCatchAll )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.getSystemHandlerArgs">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>getSystemHandlerArgs
            <span class="apidocSignatureSpan">( args, client )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.handle">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>handle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.initClient">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>initClient
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.processQueue">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>processQueue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.transition">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>transition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.Fsm.prototype.buildEventPayload">module machina.Fsm.prototype.buildEventPayload</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.buildEventPayload.buildEventPayload">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>buildEventPayload
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.Fsm.prototype.clearQueue">module machina.Fsm.prototype.clearQueue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.clearQueue.clearQueue">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>clearQueue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.Fsm.prototype.deferUntilTransition">module machina.Fsm.prototype.deferUntilTransition</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.deferUntilTransition.deferUntilTransition">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>deferUntilTransition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.Fsm.prototype.ensureClientArg">module machina.Fsm.prototype.ensureClientArg</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.ensureClientArg.ensureClientArg">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>ensureClientArg
            <span class="apidocSignatureSpan">( args )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.Fsm.prototype.ensureClientMeta">module machina.Fsm.prototype.ensureClientMeta</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.ensureClientMeta.ensureClientMeta">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>ensureClientMeta
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.Fsm.prototype.getHandlerArgs">module machina.Fsm.prototype.getHandlerArgs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.getHandlerArgs.getHandlerArgs">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>getHandlerArgs
            <span class="apidocSignatureSpan">( args, isCatchAll )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.Fsm.prototype.getSystemHandlerArgs">module machina.Fsm.prototype.getSystemHandlerArgs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.getSystemHandlerArgs.getSystemHandlerArgs">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>getSystemHandlerArgs
            <span class="apidocSignatureSpan">( args, client )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.Fsm.prototype.handle">module machina.Fsm.prototype.handle</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.handle.handle">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>handle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.Fsm.prototype.initClient">module machina.Fsm.prototype.initClient</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.initClient.initClient">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>initClient
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.Fsm.prototype.processQueue">module machina.Fsm.prototype.processQueue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.processQueue.processQueue">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>processQueue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.Fsm.prototype.transition">module machina.Fsm.prototype.transition</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.Fsm.prototype.transition.transition">
            function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>transition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.emit">module machina.emit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.emit.emit">
            function <span class="apidocSignatureSpan">machina.</span>emit
            <span class="apidocSignatureSpan">( eventName )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.machina_OLD">module machina.machina_OLD</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.machina_OLD.BehavioralFsm">
            function <span class="apidocSignatureSpan">machina.machina_OLD.</span>BehavioralFsm
            <span class="apidocSignatureSpan">( options )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.machina_OLD.Fsm">
            function <span class="apidocSignatureSpan">machina.machina_OLD.</span>Fsm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.machina_OLD.emit">
            function <span class="apidocSignatureSpan">machina.machina_OLD.</span>emit
            <span class="apidocSignatureSpan">( eventName )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.machina_OLD.off">
            function <span class="apidocSignatureSpan">machina.machina_OLD.</span>off
            <span class="apidocSignatureSpan">( eventName, callback )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.machina_OLD.on">
            function <span class="apidocSignatureSpan">machina.machina_OLD.</span>on
            <span class="apidocSignatureSpan">( eventName, callback )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machina.machina_OLD.</span>eventListeners</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machina.machina_OLD.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.off">module machina.off</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.off.off">
            function <span class="apidocSignatureSpan">machina.</span>off
            <span class="apidocSignatureSpan">( eventName, callback )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.on">module machina.on</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.on.on">
            function <span class="apidocSignatureSpan">machina.</span>on
            <span class="apidocSignatureSpan">( eventName, callback )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.utils">module machina.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.createUUID">
            function <span class="apidocSignatureSpan">machina.utils.</span>createUUID
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.extend">
            function <span class="apidocSignatureSpan">machina.utils.</span>extend
            <span class="apidocSignatureSpan">( protoProps, staticProps )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.getChildFsmInstance">
            function <span class="apidocSignatureSpan">machina.utils.</span>getChildFsmInstance
            <span class="apidocSignatureSpan">( config )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.getDefaultBehavioralOptions">
            function <span class="apidocSignatureSpan">machina.utils.</span>getDefaultBehavioralOptions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.getDefaultClientMeta">
            function <span class="apidocSignatureSpan">machina.utils.</span>getDefaultClientMeta
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.getDefaultOptions">
            function <span class="apidocSignatureSpan">machina.utils.</span>getDefaultOptions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.getLeaklessArgs">
            function <span class="apidocSignatureSpan">machina.utils.</span>getLeaklessArgs
            <span class="apidocSignatureSpan">( args, startIdx )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.listenToChild">
            function <span class="apidocSignatureSpan">machina.utils.</span>listenToChild
            <span class="apidocSignatureSpan">( fsm, child )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.makeFsmNamespace">
            function <span class="apidocSignatureSpan">machina.utils.</span>makeFsmNamespace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.utils.createUUID">module machina.utils.createUUID</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.createUUID.createUUID">
            function <span class="apidocSignatureSpan">machina.utils.</span>createUUID
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.utils.getChildFsmInstance">module machina.utils.getChildFsmInstance</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.getChildFsmInstance.getChildFsmInstance">
            function <span class="apidocSignatureSpan">machina.utils.</span>getChildFsmInstance
            <span class="apidocSignatureSpan">( config )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.utils.getDefaultBehavioralOptions">module machina.utils.getDefaultBehavioralOptions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.getDefaultBehavioralOptions.getDefaultBehavioralOptions">
            function <span class="apidocSignatureSpan">machina.utils.</span>getDefaultBehavioralOptions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.utils.getDefaultClientMeta">module machina.utils.getDefaultClientMeta</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.getDefaultClientMeta.getDefaultClientMeta">
            function <span class="apidocSignatureSpan">machina.utils.</span>getDefaultClientMeta
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.utils.getLeaklessArgs">module machina.utils.getLeaklessArgs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.getLeaklessArgs.getLeaklessArgs">
            function <span class="apidocSignatureSpan">machina.utils.</span>getLeaklessArgs
            <span class="apidocSignatureSpan">( args, startIdx )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.utils.listenToChild">module machina.utils.listenToChild</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.listenToChild.listenToChild">
            function <span class="apidocSignatureSpan">machina.utils.</span>listenToChild
            <span class="apidocSignatureSpan">( fsm, child )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machina.utils.makeFsmNamespace">module machina.utils.makeFsmNamespace</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machina.utils.makeFsmNamespace.makeFsmNamespace">
            function <span class="apidocSignatureSpan">machina.utils.</span>makeFsmNamespace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina" id="apidoc.module.machina">module machina</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm" id="apidoc.element.machina.BehavioralFsm">
        function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm
        <span class="apidocSignatureSpan">( options )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BehavioralFsm( options ) {
		_.extend( this, options );
		_.defaults( this, utils.getDefaultBehavioralOptions() );
		this.initialize.apply( this, arguments );
		topLevelEmitter.emit( events.NEW_FSM, this );
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Going Further
machina provides two constructor functions for creating an FSM: `machina.Fsm` and `machina.BehavioralFsm`:

#### The BehavioralFsm Constructor
`BehavioralFsm` is new to machina as of v1.0 (though the `Fsm` constructor now inherits from it). The `BehavioralFsm` constructor
 lets you create an FSM that defines *behavior* (hence the name) that you want applied to multiple, separate instances of *state
*. A `BehavioralFsm` instance does not (should not!) track state locally, on itself. For example, consider this scenario....where
 we get to twist our `vehicleSignal` FSM beyond reason: :smile:

```javascript
var vehicleSignal = new machina.<span class="apidocCodeKeywordSpan">BehavioralFsm</span>( {

initialize: function( options ) {
    // your setup code goes here...
},

namespace: "vehicle-signal",
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.extend" id="apidoc.element.machina.BehavioralFsm.extend">
        function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.extend
        <span class="apidocSignatureSpan">( protoProps, staticProps )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BehavioralFsm.extend = function ( protoProps, staticProps ) {
		var parent = this;
		var fsm; // placeholder for instance constructor
		var machObj = {}; // object used to hold initialState &amp; states from prototype for instance-level merging
		var Ctor = function() {}; // placeholder ctor function used to insert level in prototype chain
	
		// The constructor function for the new subclass is either defined by you
		// (the "constructor" property in your `extend` definition), or defaulted
		// by us to simply call the parent's constructor.
		if ( protoProps &amp;&amp; protoProps.hasOwnProperty( "constructor" ) ) {
			fsm = protoProps.constructor;
		} else {
			// The default machina constructor (when using inheritance) creates a
			// deep copy of the states/initialState values from the prototype and
			// extends them over the instance so that they'll be instance-level.
			// If an options arg (args[0]) is passed in, a states or intialState
			// value will be preferred over any data pulled up from the prototype.
			fsm = function() {
				var args = slice.call( arguments, 0 );
				args[ 0 ] = args[ 0 ] || {};
				var blendedState;
				var instanceStates = args[ 0 ].states || {};
				blendedState = _.merge( _.cloneDeep( machObj ), { states: instanceStates } );
				blendedState.initialState = args[ 0 ].initialState || this.initialState;
				_.extend( args[ 0 ], blendedState );
				parent.apply( this, args );
			};
		}
	
		// Inherit class (static) properties from parent.
		_.merge( fsm, parent );
	
		// Set the prototype chain to inherit from `parent`, without calling
		// `parent`'s constructor function.
		Ctor.prototype = parent.prototype;
		fsm.prototype = new Ctor();
	
		// Add prototype properties (instance properties) to the subclass,
		// if supplied.
		if ( protoProps ) {
			_.extend( fsm.prototype, protoProps );
			_.merge( machObj, _.transform( protoProps, function( accum, val, key ) {
				if ( _machKeys.indexOf( key ) !== -1 ) {
					accum[ key ] = val;
				}
			} ) );
		}
	
		// Add static properties to the constructor function, if supplied.
		if ( staticProps ) {
			_.merge( fsm, staticProps );
		}
	
		// Correctly set child's `prototype.constructor`.
		fsm.prototype.constructor = fsm;
	
		// Set a convenience property in case the parent's prototype is needed later.
		fsm.__super__ = parent.prototype;
		return fsm;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.buildEventPayload" id="apidoc.element.machina.BehavioralFsm.prototype.buildEventPayload">
        function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.buildEventPayload
        <span class="apidocSignatureSpan">( client, data )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BehavioralFsm.prototype.buildEventPayload = function ( client, data ) {
			if ( _.isPlainObject( data ) ) {
				return _.extend( data, { client: client, namespace: this.namespace } );
			} else {
				return { client: client, data: data || null, namespace: this.namespace };
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.clearQueue" id="apidoc.element.machina.BehavioralFsm.prototype.clearQueue">
        function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.clearQueue
        <span class="apidocSignatureSpan">( client, name )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BehavioralFsm.prototype.clearQueue = function ( client, name ) {
			var clientMeta = this.ensureClientMeta( client );
			if ( !name ) {
				clientMeta.inputQueue = [];
			} else {
				var filter = function( evnt ) {
					return ( name ? evnt.untilState !== name : true );
				};
				clientMeta.inputQueue = _.filter( clientMeta.inputQueue, filter );
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.compositeState" id="apidoc.element.machina.BehavioralFsm.prototype.compositeState">
        function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.compositeState
        <span class="apidocSignatureSpan">( client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BehavioralFsm.prototype.compositeState = function ( client ) {
			var clientMeta = this.ensureClientMeta( client );
			var state = clientMeta.state;
			var child = this.states[state]._child &amp;&amp; this.states[state]._child.instance;
			if ( child ) {
				state += "." + child.compositeState( client );
			}
			return state;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.configForState" id="apidoc.element.machina.BehavioralFsm.prototype.configForState">
        function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.configForState
        <span class="apidocSignatureSpan">( newState )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function configForState( newState ) {
			var newStateObj = this.states[ newState ];
			var child;
			_.each( this.hierarchy, function( childListener, key ) {
				if ( childListener &amp;&amp; typeof childListener.off === "function" ) {
					childListener.off();
				}
			} );
	
			if ( newStateObj._child ) {
				newStateObj._child = utils.getChildFsmInstance( newStateObj._child );
				child = newStateObj._child &amp;&amp; newStateObj._child.instance;
				this.hierarchy[ child.namespace ] = utils.listenToChild( this, child );
			}
	
			return child;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.deferAndTransition" id="apidoc.element.machina.BehavioralFsm.prototype.deferAndTransition">
        function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.deferAndTransition
        <span class="apidocSignatureSpan">( client, stateName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BehavioralFsm.prototype.deferAndTransition = function ( client, stateName ) {
			this.deferUntilTransition( client, stateName );
			this.transition( client, stateName );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.deferUntilTransition" id="apidoc.element.machina.BehavioralFsm.prototype.deferUntilTransition">
        function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.deferUntilTransition
        <span class="apidocSignatureSpan">( client, stateName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BehavioralFsm.prototype.deferUntilTransition = function ( client, stateName ) {
			var clientMeta = this.ensureClientMeta( client );
			if ( clientMeta.currentActionArgs ) {
				var queued = {
					type: events.NEXT_TRANSITION,
					untilState: stateName,
					args: clientMeta.currentActionArgs
				};
				clientMeta.inputQueue.push( queued );
				var eventPayload = this.buildEventPayload( client, {
					state: clientMeta.state,
					queuedArgs: queued
				} );
				this.emit( events.DEFERRED, eventPayload );
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.emit" id="apidoc.element.machina.BehavioralFsm.prototype.emit">
        function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.emit
        <span class="apidocSignatureSpan">( eventName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BehavioralFsm.prototype.emit = function ( eventName ) {
				var args = utils.getLeaklessArgs( arguments );
				if ( this.eventListeners[ "*" ] ) {
					_.each( this.eventListeners[ "*" ], function( callback ) {
						if ( !this.useSafeEmit ) {
							callback.apply( this, args );
						} else {
							try {
								callback.apply( this, args );
							} catch ( exception ) {
								<span class="apidocCodeCommentSpan">/* istanbul ignore else  */
</span>								if ( console &amp;&amp; typeof console.log !== "undefined" ) {
									console.log( exception.stack );
								}
							}
						}
					}, this );
				}
				if ( this.eventListeners[ eventName ] ) {
					_.each( this.eventListeners[ eventName ], function( callback ) {
						if ( !this.useSafeEmit ) {
							callback.apply( this, args.slice( 1 ) );
						} else {
							try {
								callback.apply( this, args.slice( 1 ) );
							} catch ( exception ) {
								/* istanbul ignore else  */
								if ( console &amp;&amp; typeof console.log !== "undefined" ) {
									console.log( exception.stack );
								}
							}
						}
					}, this );
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.ensureClientMeta" id="apidoc.element.machina.BehavioralFsm.prototype.ensureClientMeta">
        function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.ensureClientMeta
        <span class="apidocSignatureSpan">( client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ensureClientMeta( client ) {
			if ( typeof client !== "object" ) {
				throw new Error( "An FSM client must be an object." );
			}
			client[ MACHINA_PROP ] = client[ MACHINA_PROP ] || {};
			if ( !client[ MACHINA_PROP ][ this.namespace ] ) {
				client[ MACHINA_PROP ][ this.namespace ] = _.cloneDeep( utils.getDefaultClientMeta() );
				this.initClient( client );
			}
			return client[ MACHINA_PROP ][ this.namespace ];
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.getHandlerArgs" id="apidoc.element.machina.BehavioralFsm.prototype.getHandlerArgs">
        function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.getHandlerArgs
        <span class="apidocSignatureSpan">( args, isCatchAll )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BehavioralFsm.prototype.getHandlerArgs = function ( args, isCatchAll ) {
			// index 0 is the client, index 1 is inputType
			// if we're in a catch-all handler, input type needs to be included in the args
			// inputType might be an object, so we need to just get the inputType string if so
			var _args = args.slice( 0 );
			var input = _args[ 1 ];
			if ( typeof input === "object" ) {
				_args.splice( 1, 1, input.inputType );
			}
			return isCatchAll ?
				_args :
				[ _args[ 0 ] ].concat( _args.slice( 2 ) );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.getSystemHandlerArgs" id="apidoc.element.machina.BehavioralFsm.prototype.getSystemHandlerArgs">
        function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.getSystemHandlerArgs
        <span class="apidocSignatureSpan">( args, client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BehavioralFsm.prototype.getSystemHandlerArgs = function ( args, client ) {
			return [ client ].concat( args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.handle" id="apidoc.element.machina.BehavioralFsm.prototype.handle">
        function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.handle
        <span class="apidocSignatureSpan">( client, input )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BehavioralFsm.prototype.handle = function ( client, input ) {
			var inputDef = input;
			if ( typeof input === "undefined" ) {
				throw new Error( "The input argument passed to the FSM's handle method is undefined. Did you forget to pass the input name?" );
			}
			if ( typeof input === "string" ) {
				inputDef = { inputType: input, delegated: false, ticket: undefined };
			}
			var clientMeta = this.ensureClientMeta( client );
			var args = utils.getLeaklessArgs( arguments );
			if ( typeof input !== "object" ) {
				args.splice( 1, 1, inputDef );
			}
			clientMeta.currentActionArgs = args.slice( 1 );
			var currentState = clientMeta.state;
			var stateObj = this.states[ currentState ];
			var handlerName;
			var handler;
			var isCatchAll = false;
			var child;
			var result;
			var action;
			if ( !clientMeta.inExitHandler ) {
				child = this.configForState( currentState );
				if ( child &amp;&amp; !this.pendingDelegations[ inputDef.ticket ] &amp;&amp; !inputDef.bubbling ) {
					inputDef.ticket = ( inputDef.ticket || utils.createUUID() );
					inputDef.delegated = true;
					this.pendingDelegations[ inputDef.ticket ] = { delegatedTo: child.namespace };
					// WARNING - returning a value from `handle` on child FSMs is not really supported.
					// If you need to return values from child FSM input handlers, use events instead.
					result = child.handle.apply( child, args );
				} else {
					if ( inputDef.ticket &amp;&amp; this.pendingDelegations[ inputDef.ticket ] ) {
						delete this.pendingDelegations[ inputDef.ticket ];
					}
					handlerName = stateObj[ inputDef.inputType ] ? inputDef.inputType : "*";
					isCatchAll = ( handlerName === "*" );
					handler = ( stateObj[ handlerName ] || this[ handlerName ] ) || this[ "*" ];
					action = clientMeta.state + "." + handlerName;
					clientMeta.currentAction = action;
					var eventPayload = this.buildEventPayload(
						client,
						{ inputType: inputDef.inputType, delegated: inputDef.delegated, ticket: inputDef.ticket }
					);
					if ( !handler ) {
						this.emit( events.NO_HANDLER, _.extend( { args: args }, eventPayload ) );
					} else {
						this.emit( events.HANDLING, eventPayload );
						if ( typeof handler === "function" ) {
							result = handler.apply( this, this.getHandlerArgs( args, isCatchAll ) );
						} else {
							result = handler;
							this.transition( client, handler );
						}
						this.emit( events.HANDLED, eventPayload );
					}
					clientMeta.priorAction = clientMeta.currentAction;
					clientMeta.currentAction = "";
					clientMeta.currentActionArgs = undefined;
				}
			}
			return result;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.initClient" id="apidoc.element.machina.BehavioralFsm.prototype.initClient">
        function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.initClient
        <span class="apidocSignatureSpan">( client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initClient( client ) {
			var initialState = this.initialState;
			if ( !initialState ) {
				throw new Error( "You must specify an initial state for this FSM" );
			}
			if ( !this.states[ initialState ] ) {
				throw new Error( "The initial state specified does not exist in the states object." );
			}
			this.transition( client, initialState );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.initialize" id="apidoc.element.machina.BehavioralFsm.prototype.initialize">
        function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.initialize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BehavioralFsm.prototype.initialize = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.off" id="apidoc.element.machina.BehavioralFsm.prototype.off">
        function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.off
        <span class="apidocSignatureSpan">( eventName, callback )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BehavioralFsm.prototype.off = function ( eventName, callback ) {
				this.eventListeners = this.eventListeners || { "*": [] };
				if ( !eventName ) {
					this.eventListeners = {};
				} else {
					if ( callback ) {
						this.eventListeners[ eventName ] = _.without( this.eventListeners[ eventName ], callback );
					} else {
						this.eventListeners[ eventName ] = [];
					}
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.on" id="apidoc.element.machina.BehavioralFsm.prototype.on">
        function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.on
        <span class="apidocSignatureSpan">( eventName, callback )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BehavioralFsm.prototype.on = function ( eventName, callback ) {
				var self = this;
				self.eventListeners = self.eventListeners || { "*": [] };
				if ( !self.eventListeners[ eventName ] ) {
					self.eventListeners[ eventName ] = [];
				}
				self.eventListeners[ eventName ].push( callback );
				return {
					eventName: eventName,
					callback: callback,
					off: function() {
						self.off( eventName, callback );
					}
				};
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.processQueue" id="apidoc.element.machina.BehavioralFsm.prototype.processQueue">
        function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.processQueue
        <span class="apidocSignatureSpan">( client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BehavioralFsm.prototype.processQueue = function ( client ) {
			var clientMeta = this.ensureClientMeta( client );
			var filterFn = function( item ) {
				return ( ( !item.untilState ) || ( item.untilState === clientMeta.state ) );
			};
			var toProcess = _.filter( clientMeta.inputQueue, filterFn );
			clientMeta.inputQueue = _.difference( clientMeta.inputQueue, toProcess );
			_.each( toProcess, function( item ) {
				this.handle.apply( this, [ client ].concat( item.args ) );
			}, this );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.transition" id="apidoc.element.machina.BehavioralFsm.prototype.transition">
        function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm.prototype.transition
        <span class="apidocSignatureSpan">( client, newState )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BehavioralFsm.prototype.transition = function ( client, newState ) {
			var clientMeta = this.ensureClientMeta( client );
			var curState = clientMeta.state;
			var curStateObj = this.states[ curState ];
			var newStateObj = this.states[ newState ];
			var child;
			var args = utils.getLeaklessArgs( arguments ).slice( 2 );
			if ( !clientMeta.inExitHandler &amp;&amp; newState !== curState ) {
				if ( newStateObj ) {
					child = this.configForState( newState );
					if ( curStateObj &amp;&amp; curStateObj._onExit ) {
						clientMeta.inExitHandler = true;
						curStateObj._onExit.call( this, client );
						clientMeta.inExitHandler = false;
					}
					clientMeta.targetReplayState = newState;
					clientMeta.priorState = curState;
					clientMeta.state = newState;
					var eventPayload = this.buildEventPayload( client, {
						fromState: clientMeta.priorState,
						action: clientMeta.currentAction,
						toState: newState
					} );
					this.emit( events.TRANSITION, eventPayload );
					if ( newStateObj._onEnter ) {
						newStateObj._onEnter.apply( this, this.getSystemHandlerArgs( args, client ) );
						this.emit( events.TRANSITIONED, eventPayload );
					}
					if ( child ) {
						child.handle( client, "_reset" );
					}
	
					if ( clientMeta.targetReplayState === newState ) {
						this.processQueue( client, events.NEXT_TRANSITION );
					}
					return;
				}
				this.emit( events.INVALID_STATE, this.buildEventPayload( client, {
					state: clientMeta.state,
					attemptedState: newState
				} ) );
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm" id="apidoc.element.machina.Fsm">
        function <span class="apidocSignatureSpan">machina.</span>Fsm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Fsm = function () {
			BehavioralFsm.apply( this, arguments );
			this.ensureClientMeta();
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var machina = require('machina')(lodash);
var MyFsm = machina.Fsm.extend({ /* your stuff */});
```

Great, now that we know how to pull it in, let's create an FSM to represent a vehicle traffic light at a pedestrian crosswalk
:

```javascript
var vehicleSignal = new machina.<span class="apidocCodeKeywordSpan">Fsm</span>( {

// the initialize method is called right after the FSM
// instance is constructed, giving you a place for any
// setup behavior, etc. It receives the same arguments
// (options) as the constructor function.
initialize: function( options ) {
    // your setup code goes here...
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.buildEventPayload" id="apidoc.element.machina.Fsm.prototype.buildEventPayload">
        function <span class="apidocSignatureSpan">machina.</span>Fsm.prototype.buildEventPayload
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Fsm.prototype.buildEventPayload = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			var data = args[ 1 ];
			if ( _.isPlainObject( data ) ) {
				return _.extend( data, { namespace: this.namespace } );
			} else {
				return { data: data || null, namespace: this.namespace };
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.clearQueue" id="apidoc.element.machina.Fsm.prototype.clearQueue">
        function <span class="apidocSignatureSpan">machina.</span>Fsm.prototype.clearQueue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Fsm.prototype.clearQueue = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			return BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.deferUntilTransition" id="apidoc.element.machina.Fsm.prototype.deferUntilTransition">
        function <span class="apidocSignatureSpan">machina.</span>Fsm.prototype.deferUntilTransition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Fsm.prototype.deferUntilTransition = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			return BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.ensureClientArg" id="apidoc.element.machina.Fsm.prototype.ensureClientArg">
        function <span class="apidocSignatureSpan">machina.</span>Fsm.prototype.ensureClientArg
        <span class="apidocSignatureSpan">( args )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Fsm.prototype.ensureClientArg = function ( args ) {
			var _args = args;
			// we need to test the args and verify that if a client arg has
			// been passed, it must be this FSM instance (this isn't a behavioral FSM)
			if ( typeof _args[ 0 ] === "object" &amp;&amp; !( "inputType" in _args[ 0 ] ) &amp;&amp; _args[ 0 ] !== this ) {
				_args.splice( 0, 1, this );
			} else if ( typeof _args[ 0 ] !== "object" || ( typeof _args[ 0 ] === "object" &amp;&amp; ( "inputType" in _args[ 0 ] ) ) ) {
				_args.unshift( this );
			}
			return _args;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.ensureClientMeta" id="apidoc.element.machina.Fsm.prototype.ensureClientMeta">
        function <span class="apidocSignatureSpan">machina.</span>Fsm.prototype.ensureClientMeta
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ensureClientMeta() {
			if ( !this._stamped ) {
				this._stamped = true;
				_.defaults( this, _.cloneDeep( utils.getDefaultClientMeta() ) );
				this.initClient();
			}
			return this;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.getHandlerArgs" id="apidoc.element.machina.Fsm.prototype.getHandlerArgs">
        function <span class="apidocSignatureSpan">machina.</span>Fsm.prototype.getHandlerArgs
        <span class="apidocSignatureSpan">( args, isCatchAll )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Fsm.prototype.getHandlerArgs = function ( args, isCatchAll ) {
			// index 0 is the client, index 1 is inputType
			// if we're in a catch-all handler, input type needs to be included in the args
			// inputType might be an object, so we need to just get the inputType string if so
			var _args = args;
			var input = _args[ 1 ];
			if ( typeof inputType === "object" ) {
				_args.splice( 1, 1, input.inputType );
			}
			return isCatchAll ?
				_args.slice( 1 ) :
				_args.slice( 2 );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.getSystemHandlerArgs" id="apidoc.element.machina.Fsm.prototype.getSystemHandlerArgs">
        function <span class="apidocSignatureSpan">machina.</span>Fsm.prototype.getSystemHandlerArgs
        <span class="apidocSignatureSpan">( args, client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Fsm.prototype.getSystemHandlerArgs = function ( args, client ) {
			return args;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.handle" id="apidoc.element.machina.Fsm.prototype.handle">
        function <span class="apidocSignatureSpan">machina.</span>Fsm.prototype.handle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Fsm.prototype.handle = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			return BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.initClient" id="apidoc.element.machina.Fsm.prototype.initClient">
        function <span class="apidocSignatureSpan">machina.</span>Fsm.prototype.initClient
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initClient() {
			var initialState = this.initialState;
			if ( !initialState ) {
				throw new Error( "You must specify an initial state for this FSM" );
			}
			if ( !this.states[ initialState ] ) {
				throw new Error( "The initial state specified does not exist in the states object." );
			}
			this.transition( initialState );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.processQueue" id="apidoc.element.machina.Fsm.prototype.processQueue">
        function <span class="apidocSignatureSpan">machina.</span>Fsm.prototype.processQueue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Fsm.prototype.processQueue = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			return BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.transition" id="apidoc.element.machina.Fsm.prototype.transition">
        function <span class="apidocSignatureSpan">machina.</span>Fsm.prototype.transition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Fsm.prototype.transition = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			return BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.emit" id="apidoc.element.machina.emit">
        function <span class="apidocSignatureSpan">machina.</span>emit
        <span class="apidocSignatureSpan">( eventName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function ( eventName ) {
				var args = utils.getLeaklessArgs( arguments );
				if ( this.eventListeners[ "*" ] ) {
					_.each( this.eventListeners[ "*" ], function( callback ) {
						if ( !this.useSafeEmit ) {
							callback.apply( this, args );
						} else {
							try {
								callback.apply( this, args );
							} catch ( exception ) {
								<span class="apidocCodeCommentSpan">/* istanbul ignore else  */
</span>								if ( console &amp;&amp; typeof console.log !== "undefined" ) {
									console.log( exception.stack );
								}
							}
						}
					}, this );
				}
				if ( this.eventListeners[ eventName ] ) {
					_.each( this.eventListeners[ eventName ], function( callback ) {
						if ( !this.useSafeEmit ) {
							callback.apply( this, args.slice( 1 ) );
						} else {
							try {
								callback.apply( this, args.slice( 1 ) );
							} catch ( exception ) {
								/* istanbul ignore else  */
								if ( console &amp;&amp; typeof console.log !== "undefined" ) {
									console.log( exception.stack );
								}
							}
						}
					}, this );
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        green: {
// _onEnter is a special handler that is invoked
// immediately as the FSM transitions into the new state
_onEnter: function() {
    this.timer = setTimeout( function() {
        this.handle( "timeout" );
    }.bind( this ), 30000 );
    this.<span class="apidocCodeKeywordSpan">emit</span>( "vehicles", { status: "GREEN" } );
},
// If all you need to do is transition to a new state
// inside an input handler, you can provide the string
// name of the state in place of the input handler function.
timeout: "green-interruptible",
pedestrianWaiting: function() {
    this.deferUntilTransition( "green-interruptible" );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.off" id="apidoc.element.machina.off">
        function <span class="apidocSignatureSpan">machina.</span>off
        <span class="apidocSignatureSpan">( eventName, callback )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function ( eventName, callback ) {
				this.eventListeners = this.eventListeners || { "*": [] };
				if ( !eventName ) {
					this.eventListeners = {};
				} else {
					if ( callback ) {
						this.eventListeners[ eventName ] = _.without( this.eventListeners[ eventName ], callback );
					} else {
						this.eventListeners[ eventName ] = [];
					}
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Unsubscribing can be done a couple of ways:

```javascript
//each listener gets a return value
var sub = trafficLight.on("transition", someCallback);
sub.<span class="apidocCodeKeywordSpan">off</span>(); // unsubscribes the handler

// OR, we can use the FSM's prototype method -
// remove this specific subscription:
trafficLight.off("transition", someCallback);
// remove all transition subscribers
trafficLight.off("transition");
// remove ALL subscribers, period:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.on" id="apidoc.element.machina.on">
        function <span class="apidocSignatureSpan">machina.</span>on
        <span class="apidocSignatureSpan">( eventName, callback )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function ( eventName, callback ) {
				var self = this;
				self.eventListeners = self.eventListeners || { "*": [] };
				if ( !self.eventListeners[ eventName ] ) {
					self.eventListeners[ eventName ] = [];
				}
				self.eventListeners[ eventName ].push( callback );
				return {
					eventName: eventName,
					callback: callback,
					off: function() {
						self.off( eventName, callback );
					}
				};
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### And You Mentioned Events?
machina FSMs are event emitters, and subscribing to them is pretty easy:

```javascript

// I'd like to know when the transition event occurs
trafficLight.<span class="apidocCodeKeywordSpan">on</span>("transition", function (data){
    console.log("we just transitioned from " + data.fromState + " to " + data.toState);
});

// Or, maybe I want to know when ANY event occurs
trafficLight.on("*", function (eventName, data){
    console.log("this thing happened:", eventName);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.utils.createUUID" id="apidoc.element.machina.utils.createUUID">
        function <span class="apidocSignatureSpan">machina.</span>utils.createUUID
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createUUID() {
		var s = [];
		var hexDigits = "0123456789abcdef";
		for ( var i = 0; i &lt; 36; i++ ) {
			s[ i ] = hexDigits.substr( Math.floor( Math.random() * 0x10 ), 1 );
		}
		s[ 14 ] = "4"; // bits 12-15 of the time_hi_and_version field to 0010
		<span class="apidocCodeCommentSpan">/* jshint ignore:start */
</span>		s[ 19 ] = hexDigits.substr( ( s[ 19 ] &amp; 0x3 ) | 0x8, 1 ); // bits 6-7 of the clock_seq_hi_and_reserved to 01
		/* jshint ignore:end */
		s[ 8 ] = s[ 13 ] = s[ 18 ] = s[ 23 ] = "-";
		return s.join( "" );
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.utils.getChildFsmInstance" id="apidoc.element.machina.utils.getChildFsmInstance">
        function <span class="apidocSignatureSpan">machina.</span>utils.getChildFsmInstance
        <span class="apidocSignatureSpan">( config )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getChildFsmInstance( config ) {
		if ( !config ) {
			return;
		}
		var childFsmDefinition = {};
		if ( typeof config === "object" ) {
			// is this a config object with a factory?
			if ( config.factory ) {
				childFsmDefinition = config;
				childFsmDefinition.instance = childFsmDefinition.factory();
			} else {
				// assuming this is a machina instance
				childFsmDefinition.factory = function() {
					return config;
				};
			}
		} else if ( typeof config === "function" ) {
			childFsmDefinition.factory = config;
		}
		childFsmDefinition.instance = childFsmDefinition.factory();
		return childFsmDefinition;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.utils.getDefaultBehavioralOptions" id="apidoc.element.machina.utils.getDefaultBehavioralOptions">
        function <span class="apidocSignatureSpan">machina.</span>utils.getDefaultBehavioralOptions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultBehavioralOptions() {
		return {
			initialState: "uninitialized",
			eventListeners: {
				"*": []
			},
			states: {},
			namespace: makeFsmNamespace(),
			useSafeEmit: false,
			hierarchy: {},
			pendingDelegations: {}
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.utils.getDefaultClientMeta" id="apidoc.element.machina.utils.getDefaultClientMeta">
        function <span class="apidocSignatureSpan">machina.</span>utils.getDefaultClientMeta
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultClientMeta() {
		return {
			inputQueue: [],
			targetReplayState: "",
			state: undefined,
			priorState: undefined,
			priorAction: "",
			currentAction: "",
			currentActionArgs: undefined,
			inExitHandler: false
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.utils.getLeaklessArgs" id="apidoc.element.machina.utils.getLeaklessArgs">
        function <span class="apidocSignatureSpan">machina.</span>utils.getLeaklessArgs
        <span class="apidocSignatureSpan">( args, startIdx )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLeaklessArgs( args, startIdx ) {
		var result = [];
		for ( var i = ( startIdx || 0 ); i &lt; args.length; i++ ) {
			result[ i ] = args[ i ];
		}
		return result;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.utils.listenToChild" id="apidoc.element.machina.utils.listenToChild">
        function <span class="apidocSignatureSpan">machina.</span>utils.listenToChild
        <span class="apidocSignatureSpan">( fsm, child )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenToChild( fsm, child ) {
		// Need to investigate potential for discarded event
		// listener memory leak in long-running, deeply-nested hierarchies.
		return child.on( "*", function( eventName, data ) {
			switch ( eventName ) {
				case events.NO_HANDLER:
					if ( !data.ticket &amp;&amp; !data.delegated &amp;&amp; data.namespace !== fsm.namespace ) {
						// Ok - we're dealing w/ a child handling input that should bubble up
						data.args[ 1 ].bubbling = true;
					}
					// we do NOT bubble _reset inputs up to the parent
					if ( data.inputType !== "_reset" ) {
						fsm.handle.apply( fsm, data.args );
					}
					break;
				case events.HANDLING :
					var ticket = data.ticket;
					if ( ticket &amp;&amp; fsm.pendingDelegations[ ticket ] ) {
						delete fsm.pendingDelegations[ ticket ];
					}
					fsm.emit( eventName, data ); // possibly transform payload?
					break;
				default:
					fsm.emit( eventName, data ); // possibly transform payload?
					break;
			}
		} );
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.utils.makeFsmNamespace" id="apidoc.element.machina.utils.makeFsmNamespace">
        function <span class="apidocSignatureSpan">machina.</span>utils.makeFsmNamespace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utils.makeFsmNamespace = function () {
			return "fsm." + machinaCount++;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.BehavioralFsm" id="apidoc.module.machina.BehavioralFsm">module machina.BehavioralFsm</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.BehavioralFsm" id="apidoc.element.machina.BehavioralFsm.BehavioralFsm">
        function <span class="apidocSignatureSpan">machina.</span>BehavioralFsm
        <span class="apidocSignatureSpan">( options )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BehavioralFsm( options ) {
		_.extend( this, options );
		_.defaults( this, utils.getDefaultBehavioralOptions() );
		this.initialize.apply( this, arguments );
		topLevelEmitter.emit( events.NEW_FSM, this );
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Going Further
machina provides two constructor functions for creating an FSM: `machina.Fsm` and `machina.BehavioralFsm`:

#### The BehavioralFsm Constructor
`BehavioralFsm` is new to machina as of v1.0 (though the `Fsm` constructor now inherits from it). The `BehavioralFsm` constructor
 lets you create an FSM that defines *behavior* (hence the name) that you want applied to multiple, separate instances of *state
*. A `BehavioralFsm` instance does not (should not!) track state locally, on itself. For example, consider this scenario....where
 we get to twist our `vehicleSignal` FSM beyond reason: :smile:

```javascript
var vehicleSignal = new machina.<span class="apidocCodeKeywordSpan">BehavioralFsm</span>( {

initialize: function( options ) {
    // your setup code goes here...
},

namespace: "vehicle-signal",
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.extend" id="apidoc.element.machina.BehavioralFsm.extend">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.</span>extend
        <span class="apidocSignatureSpan">( protoProps, staticProps )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function ( protoProps, staticProps ) {
		var parent = this;
		var fsm; // placeholder for instance constructor
		var machObj = {}; // object used to hold initialState &amp; states from prototype for instance-level merging
		var Ctor = function() {}; // placeholder ctor function used to insert level in prototype chain
	
		// The constructor function for the new subclass is either defined by you
		// (the "constructor" property in your `extend` definition), or defaulted
		// by us to simply call the parent's constructor.
		if ( protoProps &amp;&amp; protoProps.hasOwnProperty( "constructor" ) ) {
			fsm = protoProps.constructor;
		} else {
			// The default machina constructor (when using inheritance) creates a
			// deep copy of the states/initialState values from the prototype and
			// extends them over the instance so that they'll be instance-level.
			// If an options arg (args[0]) is passed in, a states or intialState
			// value will be preferred over any data pulled up from the prototype.
			fsm = function() {
				var args = slice.call( arguments, 0 );
				args[ 0 ] = args[ 0 ] || {};
				var blendedState;
				var instanceStates = args[ 0 ].states || {};
				blendedState = _.merge( _.cloneDeep( machObj ), { states: instanceStates } );
				blendedState.initialState = args[ 0 ].initialState || this.initialState;
				_.extend( args[ 0 ], blendedState );
				parent.apply( this, args );
			};
		}
	
		// Inherit class (static) properties from parent.
		_.merge( fsm, parent );
	
		// Set the prototype chain to inherit from `parent`, without calling
		// `parent`'s constructor function.
		Ctor.prototype = parent.prototype;
		fsm.prototype = new Ctor();
	
		// Add prototype properties (instance properties) to the subclass,
		// if supplied.
		if ( protoProps ) {
			_.extend( fsm.prototype, protoProps );
			_.merge( machObj, _.transform( protoProps, function( accum, val, key ) {
				if ( _machKeys.indexOf( key ) !== -1 ) {
					accum[ key ] = val;
				}
			} ) );
		}
	
		// Add static properties to the constructor function, if supplied.
		if ( staticProps ) {
			_.merge( fsm, staticProps );
		}
	
		// Correctly set child's `prototype.constructor`.
		fsm.prototype.constructor = fsm;
	
		// Set a convenience property in case the parent's prototype is needed later.
		fsm.__super__ = parent.prototype;
		return fsm;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Quick Example

First - you need to include it in your environment (browser, node, etc.):

```javascript
// If you're not using an AMD loader, machina is available on the window
// Just make sure you have lodash loaded before machina
var MyFsm = machina.Fsm.<span class="apidocCodeKeywordSpan">extend</span>({ /* your stuff */});

// If you're using an AMD loader:
require(['machina'], function(machina){
    return machina.Fsm.extend({ /* your stuff */});
});

// node.js/CommonJS:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.BehavioralFsm.extend" id="apidoc.module.machina.BehavioralFsm.extend">module machina.BehavioralFsm.extend</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.extend.extend" id="apidoc.element.machina.BehavioralFsm.extend.extend">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.</span>extend
        <span class="apidocSignatureSpan">( protoProps, staticProps )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function ( protoProps, staticProps ) {
		var parent = this;
		var fsm; // placeholder for instance constructor
		var machObj = {}; // object used to hold initialState &amp; states from prototype for instance-level merging
		var Ctor = function() {}; // placeholder ctor function used to insert level in prototype chain
	
		// The constructor function for the new subclass is either defined by you
		// (the "constructor" property in your `extend` definition), or defaulted
		// by us to simply call the parent's constructor.
		if ( protoProps &amp;&amp; protoProps.hasOwnProperty( "constructor" ) ) {
			fsm = protoProps.constructor;
		} else {
			// The default machina constructor (when using inheritance) creates a
			// deep copy of the states/initialState values from the prototype and
			// extends them over the instance so that they'll be instance-level.
			// If an options arg (args[0]) is passed in, a states or intialState
			// value will be preferred over any data pulled up from the prototype.
			fsm = function() {
				var args = slice.call( arguments, 0 );
				args[ 0 ] = args[ 0 ] || {};
				var blendedState;
				var instanceStates = args[ 0 ].states || {};
				blendedState = _.merge( _.cloneDeep( machObj ), { states: instanceStates } );
				blendedState.initialState = args[ 0 ].initialState || this.initialState;
				_.extend( args[ 0 ], blendedState );
				parent.apply( this, args );
			};
		}
	
		// Inherit class (static) properties from parent.
		_.merge( fsm, parent );
	
		// Set the prototype chain to inherit from `parent`, without calling
		// `parent`'s constructor function.
		Ctor.prototype = parent.prototype;
		fsm.prototype = new Ctor();
	
		// Add prototype properties (instance properties) to the subclass,
		// if supplied.
		if ( protoProps ) {
			_.extend( fsm.prototype, protoProps );
			_.merge( machObj, _.transform( protoProps, function( accum, val, key ) {
				if ( _machKeys.indexOf( key ) !== -1 ) {
					accum[ key ] = val;
				}
			} ) );
		}
	
		// Add static properties to the constructor function, if supplied.
		if ( staticProps ) {
			_.merge( fsm, staticProps );
		}
	
		// Correctly set child's `prototype.constructor`.
		fsm.prototype.constructor = fsm;
	
		// Set a convenience property in case the parent's prototype is needed later.
		fsm.__super__ = parent.prototype;
		return fsm;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Quick Example

First - you need to include it in your environment (browser, node, etc.):

```javascript
// If you're not using an AMD loader, machina is available on the window
// Just make sure you have lodash loaded before machina
var MyFsm = machina.Fsm.<span class="apidocCodeKeywordSpan">extend</span>({ /* your stuff */});

// If you're using an AMD loader:
require(['machina'], function(machina){
    return machina.Fsm.extend({ /* your stuff */});
});

// node.js/CommonJS:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.BehavioralFsm.prototype" id="apidoc.module.machina.BehavioralFsm.prototype">module machina.BehavioralFsm.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.buildEventPayload" id="apidoc.element.machina.BehavioralFsm.prototype.buildEventPayload">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>buildEventPayload
        <span class="apidocSignatureSpan">( client, data )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildEventPayload = function ( client, data ) {
			if ( _.isPlainObject( data ) ) {
				return _.extend( data, { client: client, namespace: this.namespace } );
			} else {
				return { client: client, data: data || null, namespace: this.namespace };
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					delete this.pendingDelegations[ inputDef.ticket ];
				}
				handlerName = stateObj[ inputDef.inputType ] ? inputDef.inputType : "*";
				isCatchAll = ( handlerName === "*" );
				handler = ( stateObj[ handlerName ] || this[ handlerName ] ) || this[ "*" ];
				action = clientMeta.state + "." + handlerName;
				clientMeta.currentAction = action;
				var eventPayload = this.<span class="apidocCodeKeywordSpan">buildEventPayload</span>(
					client,
					{ inputType: inputDef.inputType, delegated: inputDef.delegated, ticket: inputDef.ticket }
				);
				if ( !handler ) {
					this.emit( NO_HANDLER, _.extend( { args: args }, eventPayload ) );
				} else {
					this.emit( HANDLING, eventPayload );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.clearQueue" id="apidoc.element.machina.BehavioralFsm.prototype.clearQueue">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>clearQueue
        <span class="apidocSignatureSpan">( client, name )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearQueue = function ( client, name ) {
			var clientMeta = this.ensureClientMeta( client );
			if ( !name ) {
				clientMeta.inputQueue = [];
			} else {
				var filter = function( evnt ) {
					return ( name ? evnt.untilState !== name : true );
				};
				clientMeta.inputQueue = _.filter( clientMeta.inputQueue, filter );
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.compositeState" id="apidoc.element.machina.BehavioralFsm.prototype.compositeState">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>compositeState
        <span class="apidocSignatureSpan">( client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compositeState = function ( client ) {
			var clientMeta = this.ensureClientMeta( client );
			var state = clientMeta.state;
			var child = this.states[state]._child &amp;&amp; this.states[state]._child.instance;
			if ( child ) {
				state += "." + child.compositeState( client );
			}
			return state;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* When the parent FSM transitions to a new state, any child FSM from a previous state is ignored entirely (i.e. - events emitted
, or input bubbled, will *not* be handled in the parent). If the parent FSM transitions back to that state, it will resume listening
 to the child FSM, etc.
* As the parent state transitions into any of its states, it will tell the child FSM to handle a `_reset` input. This gives you
a hook to move the child FSM to the correct state before handling any further input. For example, you'll notice our `pedestrianSignal
` FSM has a `_reset` input handler in the `dontwalk` state, which transitions the FSM to the `walking` state.

In v1.1.0, machina added the `compositeState()` method to the `BehavioralFsm` and `Fsm` prototypes. This means you can get the current
 state of the FSM hierarchy. For example:

```javascript
// calling compositeState on Fsm instances
console.log( crosswalk.<span class="apidocCodeKeywordSpan">compositeState</span>() ); // vehiclesEnabled.green

// calling compositeState on BehavioralFsm instances
// (you have to pass the client arg)
console.log( crosswalk.compositeState( fsmClient ) ); // pedestriansEnabled.walking
```

&gt;Caveats: This feature is very new to machina, so expect it to evolve a bit. I plan to fine-tune how events bubble in a hierarchy
 a bit more.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.configForState" id="apidoc.element.machina.BehavioralFsm.prototype.configForState">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>configForState
        <span class="apidocSignatureSpan">( newState )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function configForState( newState ) {
			var newStateObj = this.states[ newState ];
			var child;
			_.each( this.hierarchy, function( childListener, key ) {
				if ( childListener &amp;&amp; typeof childListener.off === "function" ) {
					childListener.off();
				}
			} );
	
			if ( newStateObj._child ) {
				newStateObj._child = utils.getChildFsmInstance( newStateObj._child );
				child = newStateObj._child &amp;&amp; newStateObj._child.instance;
				this.hierarchy[ child.namespace ] = utils.listenToChild( this, child );
			}
	
			return child;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.deferAndTransition" id="apidoc.element.machina.BehavioralFsm.prototype.deferAndTransition">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>deferAndTransition
        <span class="apidocSignatureSpan">( client, stateName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deferAndTransition = function ( client, stateName ) {
			this.deferUntilTransition( client, stateName );
			this.transition( client, stateName );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.deferUntilTransition" id="apidoc.element.machina.BehavioralFsm.prototype.deferUntilTransition">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>deferUntilTransition
        <span class="apidocSignatureSpan">( client, stateName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deferUntilTransition = function ( client, stateName ) {
			var clientMeta = this.ensureClientMeta( client );
			if ( clientMeta.currentActionArgs ) {
				var queued = {
					type: events.NEXT_TRANSITION,
					untilState: stateName,
					args: clientMeta.currentActionArgs
				};
				clientMeta.inputQueue.push( queued );
				var eventPayload = this.buildEventPayload( client, {
					state: clientMeta.state,
					queuedArgs: queued
				} );
				this.emit( events.DEFERRED, eventPayload );
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// handled while in that state.
states: {
    uninitialized: {
        // Input handlers are usually functions. They can
        // take arguments, too (even though this one doesn't)
        // The "*" handler is special (more on that in a bit)
        "*": function() {
            this.<span class="apidocCodeKeywordSpan">deferUntilTransition</span>();
            // the `transition` method takes a target state (as a string)
            // and transitions to it. You should NEVER directly assign the
            // state property on an FSM. Also - while it's certainly OK to
            // call `transition` externally, you usually end up with the
            // cleanest approach if you endeavor to transition *internally*
            // and just pass input to the FSM.
            this.transition( "green" );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.emit" id="apidoc.element.machina.BehavioralFsm.prototype.emit">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>emit
        <span class="apidocSignatureSpan">( eventName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function ( eventName ) {
				var args = utils.getLeaklessArgs( arguments );
				if ( this.eventListeners[ "*" ] ) {
					_.each( this.eventListeners[ "*" ], function( callback ) {
						if ( !this.useSafeEmit ) {
							callback.apply( this, args );
						} else {
							try {
								callback.apply( this, args );
							} catch ( exception ) {
								<span class="apidocCodeCommentSpan">/* istanbul ignore else  */
</span>								if ( console &amp;&amp; typeof console.log !== "undefined" ) {
									console.log( exception.stack );
								}
							}
						}
					}, this );
				}
				if ( this.eventListeners[ eventName ] ) {
					_.each( this.eventListeners[ eventName ], function( callback ) {
						if ( !this.useSafeEmit ) {
							callback.apply( this, args.slice( 1 ) );
						} else {
							try {
								callback.apply( this, args.slice( 1 ) );
							} catch ( exception ) {
								/* istanbul ignore else  */
								if ( console &amp;&amp; typeof console.log !== "undefined" ) {
									console.log( exception.stack );
								}
							}
						}
					}, this );
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        green: {
// _onEnter is a special handler that is invoked
// immediately as the FSM transitions into the new state
_onEnter: function() {
    this.timer = setTimeout( function() {
        this.handle( "timeout" );
    }.bind( this ), 30000 );
    this.<span class="apidocCodeKeywordSpan">emit</span>( "vehicles", { status: "GREEN" } );
},
// If all you need to do is transition to a new state
// inside an input handler, you can provide the string
// name of the state in place of the input handler function.
timeout: "green-interruptible",
pedestrianWaiting: function() {
    this.deferUntilTransition( "green-interruptible" );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.ensureClientMeta" id="apidoc.element.machina.BehavioralFsm.prototype.ensureClientMeta">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>ensureClientMeta
        <span class="apidocSignatureSpan">( client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ensureClientMeta( client ) {
			if ( typeof client !== "object" ) {
				throw new Error( "An FSM client must be an object." );
			}
			client[ MACHINA_PROP ] = client[ MACHINA_PROP ] || {};
			if ( !client[ MACHINA_PROP ][ this.namespace ] ) {
				client[ MACHINA_PROP ][ this.namespace ] = _.cloneDeep( utils.getDefaultClientMeta() );
				this.initClient( client );
			}
			return client[ MACHINA_PROP ][ this.namespace ];
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		var inputDef = input;
		if ( typeof input === "undefined" ) {
			throw new Error( "The input argument passed to the FSM's handle method is undefined. Did you forget to pass the input
 name?" );
		}
		if ( typeof input === "string" ) {
			inputDef = { inputType: input, delegated: false, ticket: undefined };
		}
		var clientMeta = this.<span class="apidocCodeKeywordSpan">ensureClientMeta</span>( client );
		var args = getLeaklessArgs( arguments );
		if ( typeof input !== "object" ) {
			args.splice( 1, 1, inputDef );
		}
		clientMeta.currentActionArgs = args.slice( 1 );
		var currentState = clientMeta.state;
		var stateObj = this.states[ currentState ];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.getHandlerArgs" id="apidoc.element.machina.BehavioralFsm.prototype.getHandlerArgs">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>getHandlerArgs
        <span class="apidocSignatureSpan">( args, isCatchAll )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHandlerArgs = function ( args, isCatchAll ) {
			// index 0 is the client, index 1 is inputType
			// if we're in a catch-all handler, input type needs to be included in the args
			// inputType might be an object, so we need to just get the inputType string if so
			var _args = args.slice( 0 );
			var input = _args[ 1 ];
			if ( typeof input === "object" ) {
				_args.splice( 1, 1, input.inputType );
			}
			return isCatchAll ?
				_args :
				[ _args[ 0 ] ].concat( _args.slice( 2 ) );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					{ inputType: inputDef.inputType, delegated: inputDef.delegated, ticket: inputDef.ticket }
				);
				if ( !handler ) {
					this.emit( NO_HANDLER, _.extend( { args: args }, eventPayload ) );
				} else {
					this.emit( HANDLING, eventPayload );
					if ( typeof handler === "function" ) {
						result = handler.apply( this, this.<span class="apidocCodeKeywordSpan">getHandlerArgs</span>( args, isCatchAll ) );
					} else {
						result = handler;
						this.transition( client, handler );
					}
					this.emit( HANDLED, eventPayload );
				}
				clientMeta.priorAction = clientMeta.currentAction;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.getSystemHandlerArgs" id="apidoc.element.machina.BehavioralFsm.prototype.getSystemHandlerArgs">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>getSystemHandlerArgs
        <span class="apidocSignatureSpan">( args, client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSystemHandlerArgs = function ( args, client ) {
			return [ client ].concat( args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.handle" id="apidoc.element.machina.BehavioralFsm.prototype.handle">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>handle
        <span class="apidocSignatureSpan">( client, input )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handle = function ( client, input ) {
			var inputDef = input;
			if ( typeof input === "undefined" ) {
				throw new Error( "The input argument passed to the FSM's handle method is undefined. Did you forget to pass the input name?" );
			}
			if ( typeof input === "string" ) {
				inputDef = { inputType: input, delegated: false, ticket: undefined };
			}
			var clientMeta = this.ensureClientMeta( client );
			var args = utils.getLeaklessArgs( arguments );
			if ( typeof input !== "object" ) {
				args.splice( 1, 1, inputDef );
			}
			clientMeta.currentActionArgs = args.slice( 1 );
			var currentState = clientMeta.state;
			var stateObj = this.states[ currentState ];
			var handlerName;
			var handler;
			var isCatchAll = false;
			var child;
			var result;
			var action;
			if ( !clientMeta.inExitHandler ) {
				child = this.configForState( currentState );
				if ( child &amp;&amp; !this.pendingDelegations[ inputDef.ticket ] &amp;&amp; !inputDef.bubbling ) {
					inputDef.ticket = ( inputDef.ticket || utils.createUUID() );
					inputDef.delegated = true;
					this.pendingDelegations[ inputDef.ticket ] = { delegatedTo: child.namespace };
					// WARNING - returning a value from `handle` on child FSMs is not really supported.
					// If you need to return values from child FSM input handlers, use events instead.
					result = child.handle.apply( child, args );
				} else {
					if ( inputDef.ticket &amp;&amp; this.pendingDelegations[ inputDef.ticket ] ) {
						delete this.pendingDelegations[ inputDef.ticket ];
					}
					handlerName = stateObj[ inputDef.inputType ] ? inputDef.inputType : "*";
					isCatchAll = ( handlerName === "*" );
					handler = ( stateObj[ handlerName ] || this[ handlerName ] ) || this[ "*" ];
					action = clientMeta.state + "." + handlerName;
					clientMeta.currentAction = action;
					var eventPayload = this.buildEventPayload(
						client,
						{ inputType: inputDef.inputType, delegated: inputDef.delegated, ticket: inputDef.ticket }
					);
					if ( !handler ) {
						this.emit( events.NO_HANDLER, _.extend( { args: args }, eventPayload ) );
					} else {
						this.emit( events.HANDLING, eventPayload );
						if ( typeof handler === "function" ) {
							result = handler.apply( this, this.getHandlerArgs( args, isCatchAll ) );
						} else {
							result = handler;
							this.transition( client, handler );
						}
						this.emit( events.HANDLED, eventPayload );
					}
					clientMeta.priorAction = clientMeta.currentAction;
					clientMeta.currentAction = "";
					clientMeta.currentActionArgs = undefined;
				}
			}
			return result;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
},
green: {
    // _onEnter is a special handler that is invoked
    // immediately as the FSM transitions into the new state
    _onEnter: function() {
        this.timer = setTimeout( function() {
            this.<span class="apidocCodeKeywordSpan">handle</span>( "timeout" );
        }.bind( this ), 30000 );
        this.emit( "vehicles", { status: "GREEN" } );
    },
    // If all you need to do is transition to a new state
    // inside an input handler, you can provide the string
    // name of the state in place of the input handler function.
    timeout: "green-interruptible",
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.initClient" id="apidoc.element.machina.BehavioralFsm.prototype.initClient">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>initClient
        <span class="apidocSignatureSpan">( client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initClient( client ) {
			var initialState = this.initialState;
			if ( !initialState ) {
				throw new Error( "You must specify an initial state for this FSM" );
			}
			if ( !this.states[ initialState ] ) {
				throw new Error( "The initial state specified does not exist in the states object." );
			}
			this.transition( client, initialState );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	ensureClientMeta: function ensureClientMeta( client ) {
		if ( typeof client !== "object" ) {
			throw new Error( "An FSM client must be an object." );
		}
		client[ MACHINA_PROP ] = client[ MACHINA_PROP ] || {};
		if ( !client[ MACHINA_PROP ][ this.namespace ] ) {
			client[ MACHINA_PROP ][ this.namespace ] = _.cloneDeep( utils.getDefaultClientMeta() );
			this.<span class="apidocCodeKeywordSpan">initClient</span>( client );
		}
		return client[ MACHINA_PROP ][ this.namespace ];
	},

	buildEventPayload: function( client, data ) {
		if ( _.isPlainObject( data ) ) {
			return _.extend( data, { client: client, namespace: this.namespace } );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.initialize" id="apidoc.element.machina.BehavioralFsm.prototype.initialize">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>initialize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.off" id="apidoc.element.machina.BehavioralFsm.prototype.off">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>off
        <span class="apidocSignatureSpan">( eventName, callback )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function ( eventName, callback ) {
				this.eventListeners = this.eventListeners || { "*": [] };
				if ( !eventName ) {
					this.eventListeners = {};
				} else {
					if ( callback ) {
						this.eventListeners[ eventName ] = _.without( this.eventListeners[ eventName ], callback );
					} else {
						this.eventListeners[ eventName ] = [];
					}
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Unsubscribing can be done a couple of ways:

```javascript
//each listener gets a return value
var sub = trafficLight.on("transition", someCallback);
sub.<span class="apidocCodeKeywordSpan">off</span>(); // unsubscribes the handler

// OR, we can use the FSM's prototype method -
// remove this specific subscription:
trafficLight.off("transition", someCallback);
// remove all transition subscribers
trafficLight.off("transition");
// remove ALL subscribers, period:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.on" id="apidoc.element.machina.BehavioralFsm.prototype.on">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>on
        <span class="apidocSignatureSpan">( eventName, callback )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function ( eventName, callback ) {
				var self = this;
				self.eventListeners = self.eventListeners || { "*": [] };
				if ( !self.eventListeners[ eventName ] ) {
					self.eventListeners[ eventName ] = [];
				}
				self.eventListeners[ eventName ].push( callback );
				return {
					eventName: eventName,
					callback: callback,
					off: function() {
						self.off( eventName, callback );
					}
				};
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### And You Mentioned Events?
machina FSMs are event emitters, and subscribing to them is pretty easy:

```javascript

// I'd like to know when the transition event occurs
trafficLight.<span class="apidocCodeKeywordSpan">on</span>("transition", function (data){
    console.log("we just transitioned from " + data.fromState + " to " + data.toState);
});

// Or, maybe I want to know when ANY event occurs
trafficLight.on("*", function (eventName, data){
    console.log("this thing happened:", eventName);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.processQueue" id="apidoc.element.machina.BehavioralFsm.prototype.processQueue">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>processQueue
        <span class="apidocSignatureSpan">( client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processQueue = function ( client ) {
			var clientMeta = this.ensureClientMeta( client );
			var filterFn = function( item ) {
				return ( ( !item.untilState ) || ( item.untilState === clientMeta.state ) );
			};
			var toProcess = _.filter( clientMeta.inputQueue, filterFn );
			clientMeta.inputQueue = _.difference( clientMeta.inputQueue, toProcess );
			_.each( toProcess, function( item ) {
				this.handle.apply( this, [ client ].concat( item.args ) );
			}, this );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					newStateObj._onEnter.call( this, client );
				}
				if ( child ) {
					child.handle( client, "_reset" );
				}

				if ( clientMeta.targetReplayState === newState ) {
					this.<span class="apidocCodeKeywordSpan">processQueue</span>( client, NEXT_TRANSITION );
				}
				return;
			}
			this.emit( INVALID_STATE, this.buildEventPayload( client, {
				state: clientMeta.state,
				attemptedState: newState
			} ) );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.transition" id="apidoc.element.machina.BehavioralFsm.prototype.transition">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>transition
        <span class="apidocSignatureSpan">( client, newState )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transition = function ( client, newState ) {
			var clientMeta = this.ensureClientMeta( client );
			var curState = clientMeta.state;
			var curStateObj = this.states[ curState ];
			var newStateObj = this.states[ newState ];
			var child;
			var args = utils.getLeaklessArgs( arguments ).slice( 2 );
			if ( !clientMeta.inExitHandler &amp;&amp; newState !== curState ) {
				if ( newStateObj ) {
					child = this.configForState( newState );
					if ( curStateObj &amp;&amp; curStateObj._onExit ) {
						clientMeta.inExitHandler = true;
						curStateObj._onExit.call( this, client );
						clientMeta.inExitHandler = false;
					}
					clientMeta.targetReplayState = newState;
					clientMeta.priorState = curState;
					clientMeta.state = newState;
					var eventPayload = this.buildEventPayload( client, {
						fromState: clientMeta.priorState,
						action: clientMeta.currentAction,
						toState: newState
					} );
					this.emit( events.TRANSITION, eventPayload );
					if ( newStateObj._onEnter ) {
						newStateObj._onEnter.apply( this, this.getSystemHandlerArgs( args, client ) );
						this.emit( events.TRANSITIONED, eventPayload );
					}
					if ( child ) {
						child.handle( client, "_reset" );
					}
	
					if ( clientMeta.targetReplayState === newState ) {
						this.processQueue( client, events.NEXT_TRANSITION );
					}
					return;
				}
				this.emit( events.INVALID_STATE, this.buildEventPayload( client, {
					state: clientMeta.state,
					attemptedState: newState
				} ) );
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.deferUntilTransition();
        // the `transition` method takes a target state (as a string)
        // and transitions to it. You should NEVER directly assign the
        // state property on an FSM. Also - while it's certainly OK to
        // call `transition` externally, you usually end up with the
        // cleanest approach if you endeavor to transition *internally*
        // and just pass input to the FSM.
        this.<span class="apidocCodeKeywordSpan">transition</span>( "green" );
    }
},
green: {
    // _onEnter is a special handler that is invoked
    // immediately as the FSM transitions into the new state
    _onEnter: function() {
        this.timer = setTimeout( function() {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.BehavioralFsm.prototype.buildEventPayload" id="apidoc.module.machina.BehavioralFsm.prototype.buildEventPayload">module machina.BehavioralFsm.prototype.buildEventPayload</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.buildEventPayload.buildEventPayload" id="apidoc.element.machina.BehavioralFsm.prototype.buildEventPayload.buildEventPayload">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>buildEventPayload
        <span class="apidocSignatureSpan">( client, data )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildEventPayload = function ( client, data ) {
			if ( _.isPlainObject( data ) ) {
				return _.extend( data, { client: client, namespace: this.namespace } );
			} else {
				return { client: client, data: data || null, namespace: this.namespace };
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					delete this.pendingDelegations[ inputDef.ticket ];
				}
				handlerName = stateObj[ inputDef.inputType ] ? inputDef.inputType : "*";
				isCatchAll = ( handlerName === "*" );
				handler = ( stateObj[ handlerName ] || this[ handlerName ] ) || this[ "*" ];
				action = clientMeta.state + "." + handlerName;
				clientMeta.currentAction = action;
				var eventPayload = this.<span class="apidocCodeKeywordSpan">buildEventPayload</span>(
					client,
					{ inputType: inputDef.inputType, delegated: inputDef.delegated, ticket: inputDef.ticket }
				);
				if ( !handler ) {
					this.emit( NO_HANDLER, _.extend( { args: args }, eventPayload ) );
				} else {
					this.emit( HANDLING, eventPayload );
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.BehavioralFsm.prototype.clearQueue" id="apidoc.module.machina.BehavioralFsm.prototype.clearQueue">module machina.BehavioralFsm.prototype.clearQueue</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.clearQueue.clearQueue" id="apidoc.element.machina.BehavioralFsm.prototype.clearQueue.clearQueue">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>clearQueue
        <span class="apidocSignatureSpan">( client, name )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearQueue = function ( client, name ) {
			var clientMeta = this.ensureClientMeta( client );
			if ( !name ) {
				clientMeta.inputQueue = [];
			} else {
				var filter = function( evnt ) {
					return ( name ? evnt.untilState !== name : true );
				};
				clientMeta.inputQueue = _.filter( clientMeta.inputQueue, filter );
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.BehavioralFsm.prototype.compositeState" id="apidoc.module.machina.BehavioralFsm.prototype.compositeState">module machina.BehavioralFsm.prototype.compositeState</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.compositeState.compositeState" id="apidoc.element.machina.BehavioralFsm.prototype.compositeState.compositeState">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>compositeState
        <span class="apidocSignatureSpan">( client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compositeState = function ( client ) {
			var clientMeta = this.ensureClientMeta( client );
			var state = clientMeta.state;
			var child = this.states[state]._child &amp;&amp; this.states[state]._child.instance;
			if ( child ) {
				state += "." + child.compositeState( client );
			}
			return state;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* When the parent FSM transitions to a new state, any child FSM from a previous state is ignored entirely (i.e. - events emitted
, or input bubbled, will *not* be handled in the parent). If the parent FSM transitions back to that state, it will resume listening
 to the child FSM, etc.
* As the parent state transitions into any of its states, it will tell the child FSM to handle a `_reset` input. This gives you
a hook to move the child FSM to the correct state before handling any further input. For example, you'll notice our `pedestrianSignal
` FSM has a `_reset` input handler in the `dontwalk` state, which transitions the FSM to the `walking` state.

In v1.1.0, machina added the `compositeState()` method to the `BehavioralFsm` and `Fsm` prototypes. This means you can get the current
 state of the FSM hierarchy. For example:

```javascript
// calling compositeState on Fsm instances
console.log( crosswalk.<span class="apidocCodeKeywordSpan">compositeState</span>() ); // vehiclesEnabled.green

// calling compositeState on BehavioralFsm instances
// (you have to pass the client arg)
console.log( crosswalk.compositeState( fsmClient ) ); // pedestriansEnabled.walking
```

&gt;Caveats: This feature is very new to machina, so expect it to evolve a bit. I plan to fine-tune how events bubble in a hierarchy
 a bit more.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.BehavioralFsm.prototype.configForState" id="apidoc.module.machina.BehavioralFsm.prototype.configForState">module machina.BehavioralFsm.prototype.configForState</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.configForState.configForState" id="apidoc.element.machina.BehavioralFsm.prototype.configForState.configForState">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>configForState
        <span class="apidocSignatureSpan">( newState )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function configForState( newState ) {
			var newStateObj = this.states[ newState ];
			var child;
			_.each( this.hierarchy, function( childListener, key ) {
				if ( childListener &amp;&amp; typeof childListener.off === "function" ) {
					childListener.off();
				}
			} );
	
			if ( newStateObj._child ) {
				newStateObj._child = utils.getChildFsmInstance( newStateObj._child );
				child = newStateObj._child &amp;&amp; newStateObj._child.instance;
				this.hierarchy[ child.namespace ] = utils.listenToChild( this, child );
			}
	
			return child;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.BehavioralFsm.prototype.deferAndTransition" id="apidoc.module.machina.BehavioralFsm.prototype.deferAndTransition">module machina.BehavioralFsm.prototype.deferAndTransition</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.deferAndTransition.deferAndTransition" id="apidoc.element.machina.BehavioralFsm.prototype.deferAndTransition.deferAndTransition">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>deferAndTransition
        <span class="apidocSignatureSpan">( client, stateName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deferAndTransition = function ( client, stateName ) {
			this.deferUntilTransition( client, stateName );
			this.transition( client, stateName );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.BehavioralFsm.prototype.deferUntilTransition" id="apidoc.module.machina.BehavioralFsm.prototype.deferUntilTransition">module machina.BehavioralFsm.prototype.deferUntilTransition</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.deferUntilTransition.deferUntilTransition" id="apidoc.element.machina.BehavioralFsm.prototype.deferUntilTransition.deferUntilTransition">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>deferUntilTransition
        <span class="apidocSignatureSpan">( client, stateName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deferUntilTransition = function ( client, stateName ) {
			var clientMeta = this.ensureClientMeta( client );
			if ( clientMeta.currentActionArgs ) {
				var queued = {
					type: events.NEXT_TRANSITION,
					untilState: stateName,
					args: clientMeta.currentActionArgs
				};
				clientMeta.inputQueue.push( queued );
				var eventPayload = this.buildEventPayload( client, {
					state: clientMeta.state,
					queuedArgs: queued
				} );
				this.emit( events.DEFERRED, eventPayload );
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// handled while in that state.
states: {
    uninitialized: {
        // Input handlers are usually functions. They can
        // take arguments, too (even though this one doesn't)
        // The "*" handler is special (more on that in a bit)
        "*": function() {
            this.<span class="apidocCodeKeywordSpan">deferUntilTransition</span>();
            // the `transition` method takes a target state (as a string)
            // and transitions to it. You should NEVER directly assign the
            // state property on an FSM. Also - while it's certainly OK to
            // call `transition` externally, you usually end up with the
            // cleanest approach if you endeavor to transition *internally*
            // and just pass input to the FSM.
            this.transition( "green" );
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.BehavioralFsm.prototype.emit" id="apidoc.module.machina.BehavioralFsm.prototype.emit">module machina.BehavioralFsm.prototype.emit</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.emit.emit" id="apidoc.element.machina.BehavioralFsm.prototype.emit.emit">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>emit
        <span class="apidocSignatureSpan">( eventName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function ( eventName ) {
				var args = utils.getLeaklessArgs( arguments );
				if ( this.eventListeners[ "*" ] ) {
					_.each( this.eventListeners[ "*" ], function( callback ) {
						if ( !this.useSafeEmit ) {
							callback.apply( this, args );
						} else {
							try {
								callback.apply( this, args );
							} catch ( exception ) {
								<span class="apidocCodeCommentSpan">/* istanbul ignore else  */
</span>								if ( console &amp;&amp; typeof console.log !== "undefined" ) {
									console.log( exception.stack );
								}
							}
						}
					}, this );
				}
				if ( this.eventListeners[ eventName ] ) {
					_.each( this.eventListeners[ eventName ], function( callback ) {
						if ( !this.useSafeEmit ) {
							callback.apply( this, args.slice( 1 ) );
						} else {
							try {
								callback.apply( this, args.slice( 1 ) );
							} catch ( exception ) {
								/* istanbul ignore else  */
								if ( console &amp;&amp; typeof console.log !== "undefined" ) {
									console.log( exception.stack );
								}
							}
						}
					}, this );
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        green: {
// _onEnter is a special handler that is invoked
// immediately as the FSM transitions into the new state
_onEnter: function() {
    this.timer = setTimeout( function() {
        this.handle( "timeout" );
    }.bind( this ), 30000 );
    this.<span class="apidocCodeKeywordSpan">emit</span>( "vehicles", { status: "GREEN" } );
},
// If all you need to do is transition to a new state
// inside an input handler, you can provide the string
// name of the state in place of the input handler function.
timeout: "green-interruptible",
pedestrianWaiting: function() {
    this.deferUntilTransition( "green-interruptible" );
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.BehavioralFsm.prototype.ensureClientMeta" id="apidoc.module.machina.BehavioralFsm.prototype.ensureClientMeta">module machina.BehavioralFsm.prototype.ensureClientMeta</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.ensureClientMeta.ensureClientMeta" id="apidoc.element.machina.BehavioralFsm.prototype.ensureClientMeta.ensureClientMeta">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>ensureClientMeta
        <span class="apidocSignatureSpan">( client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ensureClientMeta( client ) {
			if ( typeof client !== "object" ) {
				throw new Error( "An FSM client must be an object." );
			}
			client[ MACHINA_PROP ] = client[ MACHINA_PROP ] || {};
			if ( !client[ MACHINA_PROP ][ this.namespace ] ) {
				client[ MACHINA_PROP ][ this.namespace ] = _.cloneDeep( utils.getDefaultClientMeta() );
				this.initClient( client );
			}
			return client[ MACHINA_PROP ][ this.namespace ];
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		var inputDef = input;
		if ( typeof input === "undefined" ) {
			throw new Error( "The input argument passed to the FSM's handle method is undefined. Did you forget to pass the input
 name?" );
		}
		if ( typeof input === "string" ) {
			inputDef = { inputType: input, delegated: false, ticket: undefined };
		}
		var clientMeta = this.<span class="apidocCodeKeywordSpan">ensureClientMeta</span>( client );
		var args = getLeaklessArgs( arguments );
		if ( typeof input !== "object" ) {
			args.splice( 1, 1, inputDef );
		}
		clientMeta.currentActionArgs = args.slice( 1 );
		var currentState = clientMeta.state;
		var stateObj = this.states[ currentState ];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.BehavioralFsm.prototype.getHandlerArgs" id="apidoc.module.machina.BehavioralFsm.prototype.getHandlerArgs">module machina.BehavioralFsm.prototype.getHandlerArgs</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.getHandlerArgs.getHandlerArgs" id="apidoc.element.machina.BehavioralFsm.prototype.getHandlerArgs.getHandlerArgs">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>getHandlerArgs
        <span class="apidocSignatureSpan">( args, isCatchAll )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHandlerArgs = function ( args, isCatchAll ) {
			// index 0 is the client, index 1 is inputType
			// if we're in a catch-all handler, input type needs to be included in the args
			// inputType might be an object, so we need to just get the inputType string if so
			var _args = args.slice( 0 );
			var input = _args[ 1 ];
			if ( typeof input === "object" ) {
				_args.splice( 1, 1, input.inputType );
			}
			return isCatchAll ?
				_args :
				[ _args[ 0 ] ].concat( _args.slice( 2 ) );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					{ inputType: inputDef.inputType, delegated: inputDef.delegated, ticket: inputDef.ticket }
				);
				if ( !handler ) {
					this.emit( NO_HANDLER, _.extend( { args: args }, eventPayload ) );
				} else {
					this.emit( HANDLING, eventPayload );
					if ( typeof handler === "function" ) {
						result = handler.apply( this, this.<span class="apidocCodeKeywordSpan">getHandlerArgs</span>( args, isCatchAll ) );
					} else {
						result = handler;
						this.transition( client, handler );
					}
					this.emit( HANDLED, eventPayload );
				}
				clientMeta.priorAction = clientMeta.currentAction;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.BehavioralFsm.prototype.getSystemHandlerArgs" id="apidoc.module.machina.BehavioralFsm.prototype.getSystemHandlerArgs">module machina.BehavioralFsm.prototype.getSystemHandlerArgs</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.getSystemHandlerArgs.getSystemHandlerArgs" id="apidoc.element.machina.BehavioralFsm.prototype.getSystemHandlerArgs.getSystemHandlerArgs">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>getSystemHandlerArgs
        <span class="apidocSignatureSpan">( args, client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSystemHandlerArgs = function ( args, client ) {
			return [ client ].concat( args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.BehavioralFsm.prototype.handle" id="apidoc.module.machina.BehavioralFsm.prototype.handle">module machina.BehavioralFsm.prototype.handle</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.handle.handle" id="apidoc.element.machina.BehavioralFsm.prototype.handle.handle">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>handle
        <span class="apidocSignatureSpan">( client, input )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handle = function ( client, input ) {
			var inputDef = input;
			if ( typeof input === "undefined" ) {
				throw new Error( "The input argument passed to the FSM's handle method is undefined. Did you forget to pass the input name?" );
			}
			if ( typeof input === "string" ) {
				inputDef = { inputType: input, delegated: false, ticket: undefined };
			}
			var clientMeta = this.ensureClientMeta( client );
			var args = utils.getLeaklessArgs( arguments );
			if ( typeof input !== "object" ) {
				args.splice( 1, 1, inputDef );
			}
			clientMeta.currentActionArgs = args.slice( 1 );
			var currentState = clientMeta.state;
			var stateObj = this.states[ currentState ];
			var handlerName;
			var handler;
			var isCatchAll = false;
			var child;
			var result;
			var action;
			if ( !clientMeta.inExitHandler ) {
				child = this.configForState( currentState );
				if ( child &amp;&amp; !this.pendingDelegations[ inputDef.ticket ] &amp;&amp; !inputDef.bubbling ) {
					inputDef.ticket = ( inputDef.ticket || utils.createUUID() );
					inputDef.delegated = true;
					this.pendingDelegations[ inputDef.ticket ] = { delegatedTo: child.namespace };
					// WARNING - returning a value from `handle` on child FSMs is not really supported.
					// If you need to return values from child FSM input handlers, use events instead.
					result = child.handle.apply( child, args );
				} else {
					if ( inputDef.ticket &amp;&amp; this.pendingDelegations[ inputDef.ticket ] ) {
						delete this.pendingDelegations[ inputDef.ticket ];
					}
					handlerName = stateObj[ inputDef.inputType ] ? inputDef.inputType : "*";
					isCatchAll = ( handlerName === "*" );
					handler = ( stateObj[ handlerName ] || this[ handlerName ] ) || this[ "*" ];
					action = clientMeta.state + "." + handlerName;
					clientMeta.currentAction = action;
					var eventPayload = this.buildEventPayload(
						client,
						{ inputType: inputDef.inputType, delegated: inputDef.delegated, ticket: inputDef.ticket }
					);
					if ( !handler ) {
						this.emit( events.NO_HANDLER, _.extend( { args: args }, eventPayload ) );
					} else {
						this.emit( events.HANDLING, eventPayload );
						if ( typeof handler === "function" ) {
							result = handler.apply( this, this.getHandlerArgs( args, isCatchAll ) );
						} else {
							result = handler;
							this.transition( client, handler );
						}
						this.emit( events.HANDLED, eventPayload );
					}
					clientMeta.priorAction = clientMeta.currentAction;
					clientMeta.currentAction = "";
					clientMeta.currentActionArgs = undefined;
				}
			}
			return result;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
},
green: {
    // _onEnter is a special handler that is invoked
    // immediately as the FSM transitions into the new state
    _onEnter: function() {
        this.timer = setTimeout( function() {
            this.<span class="apidocCodeKeywordSpan">handle</span>( "timeout" );
        }.bind( this ), 30000 );
        this.emit( "vehicles", { status: "GREEN" } );
    },
    // If all you need to do is transition to a new state
    // inside an input handler, you can provide the string
    // name of the state in place of the input handler function.
    timeout: "green-interruptible",
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.BehavioralFsm.prototype.initClient" id="apidoc.module.machina.BehavioralFsm.prototype.initClient">module machina.BehavioralFsm.prototype.initClient</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.initClient.initClient" id="apidoc.element.machina.BehavioralFsm.prototype.initClient.initClient">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>initClient
        <span class="apidocSignatureSpan">( client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initClient( client ) {
			var initialState = this.initialState;
			if ( !initialState ) {
				throw new Error( "You must specify an initial state for this FSM" );
			}
			if ( !this.states[ initialState ] ) {
				throw new Error( "The initial state specified does not exist in the states object." );
			}
			this.transition( client, initialState );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	ensureClientMeta: function ensureClientMeta( client ) {
		if ( typeof client !== "object" ) {
			throw new Error( "An FSM client must be an object." );
		}
		client[ MACHINA_PROP ] = client[ MACHINA_PROP ] || {};
		if ( !client[ MACHINA_PROP ][ this.namespace ] ) {
			client[ MACHINA_PROP ][ this.namespace ] = _.cloneDeep( utils.getDefaultClientMeta() );
			this.<span class="apidocCodeKeywordSpan">initClient</span>( client );
		}
		return client[ MACHINA_PROP ][ this.namespace ];
	},

	buildEventPayload: function( client, data ) {
		if ( _.isPlainObject( data ) ) {
			return _.extend( data, { client: client, namespace: this.namespace } );
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.BehavioralFsm.prototype.initialize" id="apidoc.module.machina.BehavioralFsm.prototype.initialize">module machina.BehavioralFsm.prototype.initialize</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.initialize.initialize" id="apidoc.element.machina.BehavioralFsm.prototype.initialize.initialize">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>initialize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.BehavioralFsm.prototype.off" id="apidoc.module.machina.BehavioralFsm.prototype.off">module machina.BehavioralFsm.prototype.off</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.off.off" id="apidoc.element.machina.BehavioralFsm.prototype.off.off">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>off
        <span class="apidocSignatureSpan">( eventName, callback )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function ( eventName, callback ) {
				this.eventListeners = this.eventListeners || { "*": [] };
				if ( !eventName ) {
					this.eventListeners = {};
				} else {
					if ( callback ) {
						this.eventListeners[ eventName ] = _.without( this.eventListeners[ eventName ], callback );
					} else {
						this.eventListeners[ eventName ] = [];
					}
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Unsubscribing can be done a couple of ways:

```javascript
//each listener gets a return value
var sub = trafficLight.on("transition", someCallback);
sub.<span class="apidocCodeKeywordSpan">off</span>(); // unsubscribes the handler

// OR, we can use the FSM's prototype method -
// remove this specific subscription:
trafficLight.off("transition", someCallback);
// remove all transition subscribers
trafficLight.off("transition");
// remove ALL subscribers, period:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.BehavioralFsm.prototype.on" id="apidoc.module.machina.BehavioralFsm.prototype.on">module machina.BehavioralFsm.prototype.on</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.on.on" id="apidoc.element.machina.BehavioralFsm.prototype.on.on">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>on
        <span class="apidocSignatureSpan">( eventName, callback )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function ( eventName, callback ) {
				var self = this;
				self.eventListeners = self.eventListeners || { "*": [] };
				if ( !self.eventListeners[ eventName ] ) {
					self.eventListeners[ eventName ] = [];
				}
				self.eventListeners[ eventName ].push( callback );
				return {
					eventName: eventName,
					callback: callback,
					off: function() {
						self.off( eventName, callback );
					}
				};
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### And You Mentioned Events?
machina FSMs are event emitters, and subscribing to them is pretty easy:

```javascript

// I'd like to know when the transition event occurs
trafficLight.<span class="apidocCodeKeywordSpan">on</span>("transition", function (data){
    console.log("we just transitioned from " + data.fromState + " to " + data.toState);
});

// Or, maybe I want to know when ANY event occurs
trafficLight.on("*", function (eventName, data){
    console.log("this thing happened:", eventName);
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.BehavioralFsm.prototype.processQueue" id="apidoc.module.machina.BehavioralFsm.prototype.processQueue">module machina.BehavioralFsm.prototype.processQueue</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.processQueue.processQueue" id="apidoc.element.machina.BehavioralFsm.prototype.processQueue.processQueue">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>processQueue
        <span class="apidocSignatureSpan">( client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processQueue = function ( client ) {
			var clientMeta = this.ensureClientMeta( client );
			var filterFn = function( item ) {
				return ( ( !item.untilState ) || ( item.untilState === clientMeta.state ) );
			};
			var toProcess = _.filter( clientMeta.inputQueue, filterFn );
			clientMeta.inputQueue = _.difference( clientMeta.inputQueue, toProcess );
			_.each( toProcess, function( item ) {
				this.handle.apply( this, [ client ].concat( item.args ) );
			}, this );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					newStateObj._onEnter.call( this, client );
				}
				if ( child ) {
					child.handle( client, "_reset" );
				}

				if ( clientMeta.targetReplayState === newState ) {
					this.<span class="apidocCodeKeywordSpan">processQueue</span>( client, NEXT_TRANSITION );
				}
				return;
			}
			this.emit( INVALID_STATE, this.buildEventPayload( client, {
				state: clientMeta.state,
				attemptedState: newState
			} ) );
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.BehavioralFsm.prototype.transition" id="apidoc.module.machina.BehavioralFsm.prototype.transition">module machina.BehavioralFsm.prototype.transition</a></h1>


    <h2>
        <a href="#apidoc.element.machina.BehavioralFsm.prototype.transition.transition" id="apidoc.element.machina.BehavioralFsm.prototype.transition.transition">
        function <span class="apidocSignatureSpan">machina.BehavioralFsm.prototype.</span>transition
        <span class="apidocSignatureSpan">( client, newState )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transition = function ( client, newState ) {
			var clientMeta = this.ensureClientMeta( client );
			var curState = clientMeta.state;
			var curStateObj = this.states[ curState ];
			var newStateObj = this.states[ newState ];
			var child;
			var args = utils.getLeaklessArgs( arguments ).slice( 2 );
			if ( !clientMeta.inExitHandler &amp;&amp; newState !== curState ) {
				if ( newStateObj ) {
					child = this.configForState( newState );
					if ( curStateObj &amp;&amp; curStateObj._onExit ) {
						clientMeta.inExitHandler = true;
						curStateObj._onExit.call( this, client );
						clientMeta.inExitHandler = false;
					}
					clientMeta.targetReplayState = newState;
					clientMeta.priorState = curState;
					clientMeta.state = newState;
					var eventPayload = this.buildEventPayload( client, {
						fromState: clientMeta.priorState,
						action: clientMeta.currentAction,
						toState: newState
					} );
					this.emit( events.TRANSITION, eventPayload );
					if ( newStateObj._onEnter ) {
						newStateObj._onEnter.apply( this, this.getSystemHandlerArgs( args, client ) );
						this.emit( events.TRANSITIONED, eventPayload );
					}
					if ( child ) {
						child.handle( client, "_reset" );
					}
	
					if ( clientMeta.targetReplayState === newState ) {
						this.processQueue( client, events.NEXT_TRANSITION );
					}
					return;
				}
				this.emit( events.INVALID_STATE, this.buildEventPayload( client, {
					state: clientMeta.state,
					attemptedState: newState
				} ) );
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.deferUntilTransition();
        // the `transition` method takes a target state (as a string)
        // and transitions to it. You should NEVER directly assign the
        // state property on an FSM. Also - while it's certainly OK to
        // call `transition` externally, you usually end up with the
        // cleanest approach if you endeavor to transition *internally*
        // and just pass input to the FSM.
        this.<span class="apidocCodeKeywordSpan">transition</span>( "green" );
    }
},
green: {
    // _onEnter is a special handler that is invoked
    // immediately as the FSM transitions into the new state
    _onEnter: function() {
        this.timer = setTimeout( function() {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.Fsm" id="apidoc.module.machina.Fsm">module machina.Fsm</a></h1>


    <h2>
        <a href="#apidoc.element.machina.Fsm.Fsm" id="apidoc.element.machina.Fsm.Fsm">
        function <span class="apidocSignatureSpan">machina.</span>Fsm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Fsm = function () {
			BehavioralFsm.apply( this, arguments );
			this.ensureClientMeta();
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var machina = require('machina')(lodash);
var MyFsm = machina.Fsm.extend({ /* your stuff */});
```

Great, now that we know how to pull it in, let's create an FSM to represent a vehicle traffic light at a pedestrian crosswalk
:

```javascript
var vehicleSignal = new machina.<span class="apidocCodeKeywordSpan">Fsm</span>( {

// the initialize method is called right after the FSM
// instance is constructed, giving you a place for any
// setup behavior, etc. It receives the same arguments
// (options) as the constructor function.
initialize: function( options ) {
    // your setup code goes here...
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.extend" id="apidoc.element.machina.Fsm.extend">
        function <span class="apidocSignatureSpan">machina.Fsm.</span>extend
        <span class="apidocSignatureSpan">( protoProps, staticProps )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function ( protoProps, staticProps ) {
		var parent = this;
		var fsm; // placeholder for instance constructor
		var machObj = {}; // object used to hold initialState &amp; states from prototype for instance-level merging
		var Ctor = function() {}; // placeholder ctor function used to insert level in prototype chain
	
		// The constructor function for the new subclass is either defined by you
		// (the "constructor" property in your `extend` definition), or defaulted
		// by us to simply call the parent's constructor.
		if ( protoProps &amp;&amp; protoProps.hasOwnProperty( "constructor" ) ) {
			fsm = protoProps.constructor;
		} else {
			// The default machina constructor (when using inheritance) creates a
			// deep copy of the states/initialState values from the prototype and
			// extends them over the instance so that they'll be instance-level.
			// If an options arg (args[0]) is passed in, a states or intialState
			// value will be preferred over any data pulled up from the prototype.
			fsm = function() {
				var args = slice.call( arguments, 0 );
				args[ 0 ] = args[ 0 ] || {};
				var blendedState;
				var instanceStates = args[ 0 ].states || {};
				blendedState = _.merge( _.cloneDeep( machObj ), { states: instanceStates } );
				blendedState.initialState = args[ 0 ].initialState || this.initialState;
				_.extend( args[ 0 ], blendedState );
				parent.apply( this, args );
			};
		}
	
		// Inherit class (static) properties from parent.
		_.merge( fsm, parent );
	
		// Set the prototype chain to inherit from `parent`, without calling
		// `parent`'s constructor function.
		Ctor.prototype = parent.prototype;
		fsm.prototype = new Ctor();
	
		// Add prototype properties (instance properties) to the subclass,
		// if supplied.
		if ( protoProps ) {
			_.extend( fsm.prototype, protoProps );
			_.merge( machObj, _.transform( protoProps, function( accum, val, key ) {
				if ( _machKeys.indexOf( key ) !== -1 ) {
					accum[ key ] = val;
				}
			} ) );
		}
	
		// Add static properties to the constructor function, if supplied.
		if ( staticProps ) {
			_.merge( fsm, staticProps );
		}
	
		// Correctly set child's `prototype.constructor`.
		fsm.prototype.constructor = fsm;
	
		// Set a convenience property in case the parent's prototype is needed later.
		fsm.__super__ = parent.prototype;
		return fsm;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Quick Example

First - you need to include it in your environment (browser, node, etc.):

```javascript
// If you're not using an AMD loader, machina is available on the window
// Just make sure you have lodash loaded before machina
var MyFsm = machina.Fsm.<span class="apidocCodeKeywordSpan">extend</span>({ /* your stuff */});

// If you're using an AMD loader:
require(['machina'], function(machina){
    return machina.Fsm.extend({ /* your stuff */});
});

// node.js/CommonJS:
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.Fsm.prototype" id="apidoc.module.machina.Fsm.prototype">module machina.Fsm.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.buildEventPayload" id="apidoc.element.machina.Fsm.prototype.buildEventPayload">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>buildEventPayload
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildEventPayload = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			var data = args[ 1 ];
			if ( _.isPlainObject( data ) ) {
				return _.extend( data, { namespace: this.namespace } );
			} else {
				return { data: data || null, namespace: this.namespace };
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					delete this.pendingDelegations[ inputDef.ticket ];
				}
				handlerName = stateObj[ inputDef.inputType ] ? inputDef.inputType : "*";
				isCatchAll = ( handlerName === "*" );
				handler = ( stateObj[ handlerName ] || this[ handlerName ] ) || this[ "*" ];
				action = clientMeta.state + "." + handlerName;
				clientMeta.currentAction = action;
				var eventPayload = this.<span class="apidocCodeKeywordSpan">buildEventPayload</span>(
					client,
					{ inputType: inputDef.inputType, delegated: inputDef.delegated, ticket: inputDef.ticket }
				);
				if ( !handler ) {
					this.emit( NO_HANDLER, _.extend( { args: args }, eventPayload ) );
				} else {
					this.emit( HANDLING, eventPayload );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.clearQueue" id="apidoc.element.machina.Fsm.prototype.clearQueue">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>clearQueue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearQueue = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			return BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.constructor" id="apidoc.element.machina.Fsm.prototype.constructor">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function () {
			BehavioralFsm.apply( this, arguments );
			this.ensureClientMeta();
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.deferUntilTransition" id="apidoc.element.machina.Fsm.prototype.deferUntilTransition">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>deferUntilTransition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deferUntilTransition = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			return BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// handled while in that state.
states: {
    uninitialized: {
        // Input handlers are usually functions. They can
        // take arguments, too (even though this one doesn't)
        // The "*" handler is special (more on that in a bit)
        "*": function() {
            this.<span class="apidocCodeKeywordSpan">deferUntilTransition</span>();
            // the `transition` method takes a target state (as a string)
            // and transitions to it. You should NEVER directly assign the
            // state property on an FSM. Also - while it's certainly OK to
            // call `transition` externally, you usually end up with the
            // cleanest approach if you endeavor to transition *internally*
            // and just pass input to the FSM.
            this.transition( "green" );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.ensureClientArg" id="apidoc.element.machina.Fsm.prototype.ensureClientArg">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>ensureClientArg
        <span class="apidocSignatureSpan">( args )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureClientArg = function ( args ) {
			var _args = args;
			// we need to test the args and verify that if a client arg has
			// been passed, it must be this FSM instance (this isn't a behavioral FSM)
			if ( typeof _args[ 0 ] === "object" &amp;&amp; !( "inputType" in _args[ 0 ] ) &amp;&amp; _args[ 0 ] !== this ) {
				_args.splice( 0, 1, this );
			} else if ( typeof _args[ 0 ] !== "object" || ( typeof _args[ 0 ] === "object" &amp;&amp; ( "inputType" in _args[ 0 ] ) ) ) {
				_args.unshift( this );
			}
			return _args;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		}
		return isCatchAll ?
			_args.slice( 1 ) :
			_args.slice( 2 );
	},
	// "classic" machina FSM do not emit the client property on events (which would be the FSM itself)
	buildEventPayload: function() {
		var args = this.<span class="apidocCodeKeywordSpan">ensureClientArg</span>( utils.getLeaklessArgs( arguments ) );
		var data = args[ 1 ];
		if ( _.isPlainObject( data ) ) {
			return _.extend( data, { namespace: this.namespace } );
		} else {
			return { data: data || null, namespace: this.namespace };
		}
	}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.ensureClientMeta" id="apidoc.element.machina.Fsm.prototype.ensureClientMeta">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>ensureClientMeta
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ensureClientMeta() {
			if ( !this._stamped ) {
				this._stamped = true;
				_.defaults( this, _.cloneDeep( utils.getDefaultClientMeta() ) );
				this.initClient();
			}
			return this;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		var inputDef = input;
		if ( typeof input === "undefined" ) {
			throw new Error( "The input argument passed to the FSM's handle method is undefined. Did you forget to pass the input
 name?" );
		}
		if ( typeof input === "string" ) {
			inputDef = { inputType: input, delegated: false, ticket: undefined };
		}
		var clientMeta = this.<span class="apidocCodeKeywordSpan">ensureClientMeta</span>( client );
		var args = getLeaklessArgs( arguments );
		if ( typeof input !== "object" ) {
			args.splice( 1, 1, inputDef );
		}
		clientMeta.currentActionArgs = args.slice( 1 );
		var currentState = clientMeta.state;
		var stateObj = this.states[ currentState ];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.getHandlerArgs" id="apidoc.element.machina.Fsm.prototype.getHandlerArgs">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>getHandlerArgs
        <span class="apidocSignatureSpan">( args, isCatchAll )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHandlerArgs = function ( args, isCatchAll ) {
			// index 0 is the client, index 1 is inputType
			// if we're in a catch-all handler, input type needs to be included in the args
			// inputType might be an object, so we need to just get the inputType string if so
			var _args = args;
			var input = _args[ 1 ];
			if ( typeof inputType === "object" ) {
				_args.splice( 1, 1, input.inputType );
			}
			return isCatchAll ?
				_args.slice( 1 ) :
				_args.slice( 2 );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					{ inputType: inputDef.inputType, delegated: inputDef.delegated, ticket: inputDef.ticket }
				);
				if ( !handler ) {
					this.emit( NO_HANDLER, _.extend( { args: args }, eventPayload ) );
				} else {
					this.emit( HANDLING, eventPayload );
					if ( typeof handler === "function" ) {
						result = handler.apply( this, this.<span class="apidocCodeKeywordSpan">getHandlerArgs</span>( args, isCatchAll ) );
					} else {
						result = handler;
						this.transition( client, handler );
					}
					this.emit( HANDLED, eventPayload );
				}
				clientMeta.priorAction = clientMeta.currentAction;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.getSystemHandlerArgs" id="apidoc.element.machina.Fsm.prototype.getSystemHandlerArgs">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>getSystemHandlerArgs
        <span class="apidocSignatureSpan">( args, client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSystemHandlerArgs = function ( args, client ) {
			return args;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.handle" id="apidoc.element.machina.Fsm.prototype.handle">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>handle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handle = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			return BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
},
green: {
    // _onEnter is a special handler that is invoked
    // immediately as the FSM transitions into the new state
    _onEnter: function() {
        this.timer = setTimeout( function() {
            this.<span class="apidocCodeKeywordSpan">handle</span>( "timeout" );
        }.bind( this ), 30000 );
        this.emit( "vehicles", { status: "GREEN" } );
    },
    // If all you need to do is transition to a new state
    // inside an input handler, you can provide the string
    // name of the state in place of the input handler function.
    timeout: "green-interruptible",
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.initClient" id="apidoc.element.machina.Fsm.prototype.initClient">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>initClient
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initClient() {
			var initialState = this.initialState;
			if ( !initialState ) {
				throw new Error( "You must specify an initial state for this FSM" );
			}
			if ( !this.states[ initialState ] ) {
				throw new Error( "The initial state specified does not exist in the states object." );
			}
			this.transition( initialState );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	ensureClientMeta: function ensureClientMeta( client ) {
		if ( typeof client !== "object" ) {
			throw new Error( "An FSM client must be an object." );
		}
		client[ MACHINA_PROP ] = client[ MACHINA_PROP ] || {};
		if ( !client[ MACHINA_PROP ][ this.namespace ] ) {
			client[ MACHINA_PROP ][ this.namespace ] = _.cloneDeep( utils.getDefaultClientMeta() );
			this.<span class="apidocCodeKeywordSpan">initClient</span>( client );
		}
		return client[ MACHINA_PROP ][ this.namespace ];
	},

	buildEventPayload: function( client, data ) {
		if ( _.isPlainObject( data ) ) {
			return _.extend( data, { client: client, namespace: this.namespace } );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.processQueue" id="apidoc.element.machina.Fsm.prototype.processQueue">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>processQueue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processQueue = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			return BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					newStateObj._onEnter.call( this, client );
				}
				if ( child ) {
					child.handle( client, "_reset" );
				}

				if ( clientMeta.targetReplayState === newState ) {
					this.<span class="apidocCodeKeywordSpan">processQueue</span>( client, NEXT_TRANSITION );
				}
				return;
			}
			this.emit( INVALID_STATE, this.buildEventPayload( client, {
				state: clientMeta.state,
				attemptedState: newState
			} ) );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.transition" id="apidoc.element.machina.Fsm.prototype.transition">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>transition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transition = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			return BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.deferUntilTransition();
        // the `transition` method takes a target state (as a string)
        // and transitions to it. You should NEVER directly assign the
        // state property on an FSM. Also - while it's certainly OK to
        // call `transition` externally, you usually end up with the
        // cleanest approach if you endeavor to transition *internally*
        // and just pass input to the FSM.
        this.<span class="apidocCodeKeywordSpan">transition</span>( "green" );
    }
},
green: {
    // _onEnter is a special handler that is invoked
    // immediately as the FSM transitions into the new state
    _onEnter: function() {
        this.timer = setTimeout( function() {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.Fsm.prototype.buildEventPayload" id="apidoc.module.machina.Fsm.prototype.buildEventPayload">module machina.Fsm.prototype.buildEventPayload</a></h1>


    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.buildEventPayload.buildEventPayload" id="apidoc.element.machina.Fsm.prototype.buildEventPayload.buildEventPayload">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>buildEventPayload
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildEventPayload = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			var data = args[ 1 ];
			if ( _.isPlainObject( data ) ) {
				return _.extend( data, { namespace: this.namespace } );
			} else {
				return { data: data || null, namespace: this.namespace };
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					delete this.pendingDelegations[ inputDef.ticket ];
				}
				handlerName = stateObj[ inputDef.inputType ] ? inputDef.inputType : "*";
				isCatchAll = ( handlerName === "*" );
				handler = ( stateObj[ handlerName ] || this[ handlerName ] ) || this[ "*" ];
				action = clientMeta.state + "." + handlerName;
				clientMeta.currentAction = action;
				var eventPayload = this.<span class="apidocCodeKeywordSpan">buildEventPayload</span>(
					client,
					{ inputType: inputDef.inputType, delegated: inputDef.delegated, ticket: inputDef.ticket }
				);
				if ( !handler ) {
					this.emit( NO_HANDLER, _.extend( { args: args }, eventPayload ) );
				} else {
					this.emit( HANDLING, eventPayload );
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.Fsm.prototype.clearQueue" id="apidoc.module.machina.Fsm.prototype.clearQueue">module machina.Fsm.prototype.clearQueue</a></h1>


    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.clearQueue.clearQueue" id="apidoc.element.machina.Fsm.prototype.clearQueue.clearQueue">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>clearQueue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearQueue = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			return BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.Fsm.prototype.deferUntilTransition" id="apidoc.module.machina.Fsm.prototype.deferUntilTransition">module machina.Fsm.prototype.deferUntilTransition</a></h1>


    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.deferUntilTransition.deferUntilTransition" id="apidoc.element.machina.Fsm.prototype.deferUntilTransition.deferUntilTransition">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>deferUntilTransition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deferUntilTransition = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			return BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// handled while in that state.
states: {
    uninitialized: {
        // Input handlers are usually functions. They can
        // take arguments, too (even though this one doesn't)
        // The "*" handler is special (more on that in a bit)
        "*": function() {
            this.<span class="apidocCodeKeywordSpan">deferUntilTransition</span>();
            // the `transition` method takes a target state (as a string)
            // and transitions to it. You should NEVER directly assign the
            // state property on an FSM. Also - while it's certainly OK to
            // call `transition` externally, you usually end up with the
            // cleanest approach if you endeavor to transition *internally*
            // and just pass input to the FSM.
            this.transition( "green" );
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.Fsm.prototype.ensureClientArg" id="apidoc.module.machina.Fsm.prototype.ensureClientArg">module machina.Fsm.prototype.ensureClientArg</a></h1>


    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.ensureClientArg.ensureClientArg" id="apidoc.element.machina.Fsm.prototype.ensureClientArg.ensureClientArg">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>ensureClientArg
        <span class="apidocSignatureSpan">( args )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureClientArg = function ( args ) {
			var _args = args;
			// we need to test the args and verify that if a client arg has
			// been passed, it must be this FSM instance (this isn't a behavioral FSM)
			if ( typeof _args[ 0 ] === "object" &amp;&amp; !( "inputType" in _args[ 0 ] ) &amp;&amp; _args[ 0 ] !== this ) {
				_args.splice( 0, 1, this );
			} else if ( typeof _args[ 0 ] !== "object" || ( typeof _args[ 0 ] === "object" &amp;&amp; ( "inputType" in _args[ 0 ] ) ) ) {
				_args.unshift( this );
			}
			return _args;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		}
		return isCatchAll ?
			_args.slice( 1 ) :
			_args.slice( 2 );
	},
	// "classic" machina FSM do not emit the client property on events (which would be the FSM itself)
	buildEventPayload: function() {
		var args = this.<span class="apidocCodeKeywordSpan">ensureClientArg</span>( utils.getLeaklessArgs( arguments ) );
		var data = args[ 1 ];
		if ( _.isPlainObject( data ) ) {
			return _.extend( data, { namespace: this.namespace } );
		} else {
			return { data: data || null, namespace: this.namespace };
		}
	}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.Fsm.prototype.ensureClientMeta" id="apidoc.module.machina.Fsm.prototype.ensureClientMeta">module machina.Fsm.prototype.ensureClientMeta</a></h1>


    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.ensureClientMeta.ensureClientMeta" id="apidoc.element.machina.Fsm.prototype.ensureClientMeta.ensureClientMeta">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>ensureClientMeta
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ensureClientMeta() {
			if ( !this._stamped ) {
				this._stamped = true;
				_.defaults( this, _.cloneDeep( utils.getDefaultClientMeta() ) );
				this.initClient();
			}
			return this;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		var inputDef = input;
		if ( typeof input === "undefined" ) {
			throw new Error( "The input argument passed to the FSM's handle method is undefined. Did you forget to pass the input
 name?" );
		}
		if ( typeof input === "string" ) {
			inputDef = { inputType: input, delegated: false, ticket: undefined };
		}
		var clientMeta = this.<span class="apidocCodeKeywordSpan">ensureClientMeta</span>( client );
		var args = getLeaklessArgs( arguments );
		if ( typeof input !== "object" ) {
			args.splice( 1, 1, inputDef );
		}
		clientMeta.currentActionArgs = args.slice( 1 );
		var currentState = clientMeta.state;
		var stateObj = this.states[ currentState ];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.Fsm.prototype.getHandlerArgs" id="apidoc.module.machina.Fsm.prototype.getHandlerArgs">module machina.Fsm.prototype.getHandlerArgs</a></h1>


    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.getHandlerArgs.getHandlerArgs" id="apidoc.element.machina.Fsm.prototype.getHandlerArgs.getHandlerArgs">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>getHandlerArgs
        <span class="apidocSignatureSpan">( args, isCatchAll )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHandlerArgs = function ( args, isCatchAll ) {
			// index 0 is the client, index 1 is inputType
			// if we're in a catch-all handler, input type needs to be included in the args
			// inputType might be an object, so we need to just get the inputType string if so
			var _args = args;
			var input = _args[ 1 ];
			if ( typeof inputType === "object" ) {
				_args.splice( 1, 1, input.inputType );
			}
			return isCatchAll ?
				_args.slice( 1 ) :
				_args.slice( 2 );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					{ inputType: inputDef.inputType, delegated: inputDef.delegated, ticket: inputDef.ticket }
				);
				if ( !handler ) {
					this.emit( NO_HANDLER, _.extend( { args: args }, eventPayload ) );
				} else {
					this.emit( HANDLING, eventPayload );
					if ( typeof handler === "function" ) {
						result = handler.apply( this, this.<span class="apidocCodeKeywordSpan">getHandlerArgs</span>( args, isCatchAll ) );
					} else {
						result = handler;
						this.transition( client, handler );
					}
					this.emit( HANDLED, eventPayload );
				}
				clientMeta.priorAction = clientMeta.currentAction;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.Fsm.prototype.getSystemHandlerArgs" id="apidoc.module.machina.Fsm.prototype.getSystemHandlerArgs">module machina.Fsm.prototype.getSystemHandlerArgs</a></h1>


    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.getSystemHandlerArgs.getSystemHandlerArgs" id="apidoc.element.machina.Fsm.prototype.getSystemHandlerArgs.getSystemHandlerArgs">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>getSystemHandlerArgs
        <span class="apidocSignatureSpan">( args, client )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSystemHandlerArgs = function ( args, client ) {
			return args;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.Fsm.prototype.handle" id="apidoc.module.machina.Fsm.prototype.handle">module machina.Fsm.prototype.handle</a></h1>


    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.handle.handle" id="apidoc.element.machina.Fsm.prototype.handle.handle">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>handle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handle = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			return BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
},
green: {
    // _onEnter is a special handler that is invoked
    // immediately as the FSM transitions into the new state
    _onEnter: function() {
        this.timer = setTimeout( function() {
            this.<span class="apidocCodeKeywordSpan">handle</span>( "timeout" );
        }.bind( this ), 30000 );
        this.emit( "vehicles", { status: "GREEN" } );
    },
    // If all you need to do is transition to a new state
    // inside an input handler, you can provide the string
    // name of the state in place of the input handler function.
    timeout: "green-interruptible",
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.Fsm.prototype.initClient" id="apidoc.module.machina.Fsm.prototype.initClient">module machina.Fsm.prototype.initClient</a></h1>


    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.initClient.initClient" id="apidoc.element.machina.Fsm.prototype.initClient.initClient">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>initClient
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initClient() {
			var initialState = this.initialState;
			if ( !initialState ) {
				throw new Error( "You must specify an initial state for this FSM" );
			}
			if ( !this.states[ initialState ] ) {
				throw new Error( "The initial state specified does not exist in the states object." );
			}
			this.transition( initialState );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	ensureClientMeta: function ensureClientMeta( client ) {
		if ( typeof client !== "object" ) {
			throw new Error( "An FSM client must be an object." );
		}
		client[ MACHINA_PROP ] = client[ MACHINA_PROP ] || {};
		if ( !client[ MACHINA_PROP ][ this.namespace ] ) {
			client[ MACHINA_PROP ][ this.namespace ] = _.cloneDeep( utils.getDefaultClientMeta() );
			this.<span class="apidocCodeKeywordSpan">initClient</span>( client );
		}
		return client[ MACHINA_PROP ][ this.namespace ];
	},

	buildEventPayload: function( client, data ) {
		if ( _.isPlainObject( data ) ) {
			return _.extend( data, { client: client, namespace: this.namespace } );
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.Fsm.prototype.processQueue" id="apidoc.module.machina.Fsm.prototype.processQueue">module machina.Fsm.prototype.processQueue</a></h1>


    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.processQueue.processQueue" id="apidoc.element.machina.Fsm.prototype.processQueue.processQueue">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>processQueue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processQueue = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			return BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					newStateObj._onEnter.call( this, client );
				}
				if ( child ) {
					child.handle( client, "_reset" );
				}

				if ( clientMeta.targetReplayState === newState ) {
					this.<span class="apidocCodeKeywordSpan">processQueue</span>( client, NEXT_TRANSITION );
				}
				return;
			}
			this.emit( INVALID_STATE, this.buildEventPayload( client, {
				state: clientMeta.state,
				attemptedState: newState
			} ) );
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.Fsm.prototype.transition" id="apidoc.module.machina.Fsm.prototype.transition">module machina.Fsm.prototype.transition</a></h1>


    <h2>
        <a href="#apidoc.element.machina.Fsm.prototype.transition.transition" id="apidoc.element.machina.Fsm.prototype.transition.transition">
        function <span class="apidocSignatureSpan">machina.Fsm.prototype.</span>transition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transition = function () {
			var args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );
			return BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.deferUntilTransition();
        // the `transition` method takes a target state (as a string)
        // and transitions to it. You should NEVER directly assign the
        // state property on an FSM. Also - while it's certainly OK to
        // call `transition` externally, you usually end up with the
        // cleanest approach if you endeavor to transition *internally*
        // and just pass input to the FSM.
        this.<span class="apidocCodeKeywordSpan">transition</span>( "green" );
    }
},
green: {
    // _onEnter is a special handler that is invoked
    // immediately as the FSM transitions into the new state
    _onEnter: function() {
        this.timer = setTimeout( function() {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.emit" id="apidoc.module.machina.emit">module machina.emit</a></h1>


    <h2>
        <a href="#apidoc.element.machina.emit.emit" id="apidoc.element.machina.emit.emit">
        function <span class="apidocSignatureSpan">machina.</span>emit
        <span class="apidocSignatureSpan">( eventName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function ( eventName ) {
				var args = utils.getLeaklessArgs( arguments );
				if ( this.eventListeners[ "*" ] ) {
					_.each( this.eventListeners[ "*" ], function( callback ) {
						if ( !this.useSafeEmit ) {
							callback.apply( this, args );
						} else {
							try {
								callback.apply( this, args );
							} catch ( exception ) {
								<span class="apidocCodeCommentSpan">/* istanbul ignore else  */
</span>								if ( console &amp;&amp; typeof console.log !== "undefined" ) {
									console.log( exception.stack );
								}
							}
						}
					}, this );
				}
				if ( this.eventListeners[ eventName ] ) {
					_.each( this.eventListeners[ eventName ], function( callback ) {
						if ( !this.useSafeEmit ) {
							callback.apply( this, args.slice( 1 ) );
						} else {
							try {
								callback.apply( this, args.slice( 1 ) );
							} catch ( exception ) {
								/* istanbul ignore else  */
								if ( console &amp;&amp; typeof console.log !== "undefined" ) {
									console.log( exception.stack );
								}
							}
						}
					}, this );
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        green: {
// _onEnter is a special handler that is invoked
// immediately as the FSM transitions into the new state
_onEnter: function() {
    this.timer = setTimeout( function() {
        this.handle( "timeout" );
    }.bind( this ), 30000 );
    this.<span class="apidocCodeKeywordSpan">emit</span>( "vehicles", { status: "GREEN" } );
},
// If all you need to do is transition to a new state
// inside an input handler, you can provide the string
// name of the state in place of the input handler function.
timeout: "green-interruptible",
pedestrianWaiting: function() {
    this.deferUntilTransition( "green-interruptible" );
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.machina_OLD" id="apidoc.module.machina.machina_OLD">module machina.machina_OLD</a></h1>


    <h2>
        <a href="#apidoc.element.machina.machina_OLD.BehavioralFsm" id="apidoc.element.machina.machina_OLD.BehavioralFsm">
        function <span class="apidocSignatureSpan">machina.machina_OLD.</span>BehavioralFsm
        <span class="apidocSignatureSpan">( options )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BehavioralFsm( options ) {
	_.extend( this, options );
	_.defaults( this, getDefaultBehavioralOptions() );
	this.initialize.apply( this, arguments );
	machina.emit( NEW_FSM, this );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Going Further
machina provides two constructor functions for creating an FSM: `machina.Fsm` and `machina.BehavioralFsm`:

#### The BehavioralFsm Constructor
`BehavioralFsm` is new to machina as of v1.0 (though the `Fsm` constructor now inherits from it). The `BehavioralFsm` constructor
 lets you create an FSM that defines *behavior* (hence the name) that you want applied to multiple, separate instances of *state
*. A `BehavioralFsm` instance does not (should not!) track state locally, on itself. For example, consider this scenario....where
 we get to twist our `vehicleSignal` FSM beyond reason: :smile:

```javascript
var vehicleSignal = new machina.<span class="apidocCodeKeywordSpan">BehavioralFsm</span>( {

initialize: function( options ) {
    // your setup code goes here...
},

namespace: "vehicle-signal",
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.machina_OLD.Fsm" id="apidoc.element.machina.machina_OLD.Fsm">
        function <span class="apidocSignatureSpan">machina.machina_OLD.</span>Fsm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Fsm = function () {
		BehavioralFsm.apply( this, arguments );
		this.ensureClientMeta();
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var machina = require('machina')(lodash);
var MyFsm = machina.Fsm.extend({ /* your stuff */});
```

Great, now that we know how to pull it in, let's create an FSM to represent a vehicle traffic light at a pedestrian crosswalk
:

```javascript
var vehicleSignal = new machina.<span class="apidocCodeKeywordSpan">Fsm</span>( {

// the initialize method is called right after the FSM
// instance is constructed, giving you a place for any
// setup behavior, etc. It receives the same arguments
// (options) as the constructor function.
initialize: function( options ) {
    // your setup code goes here...
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.machina_OLD.emit" id="apidoc.element.machina.machina_OLD.emit">
        function <span class="apidocSignatureSpan">machina.machina_OLD.</span>emit
        <span class="apidocSignatureSpan">( eventName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function ( eventName ) {
		var args = getLeaklessArgs( arguments );
		if ( this.eventListeners[ "*" ] ) {
			_.each( this.eventListeners[ "*" ], function( callback ) {
				if ( !this.useSafeEmit ) {
					callback.apply( this, args );
				} else {
					try {
						callback.apply( this, args );
					} catch ( exception ) {
						<span class="apidocCodeCommentSpan">/* istanbul ignore else  */
</span>						if ( console &amp;&amp; typeof console.log !== "undefined" ) {
							console.log( exception.stack );
						}
					}
				}
			}, this );
		}
		if ( this.eventListeners[ eventName ] ) {
			_.each( this.eventListeners[ eventName ], function( callback ) {
				if ( !this.useSafeEmit ) {
					callback.apply( this, args.slice( 1 ) );
				} else {
					try {
						callback.apply( this, args.slice( 1 ) );
					} catch ( exception ) {
						/* istanbul ignore else  */
						if ( console &amp;&amp; typeof console.log !== "undefined" ) {
							console.log( exception.stack );
						}
					}
				}
			}, this );
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        green: {
// _onEnter is a special handler that is invoked
// immediately as the FSM transitions into the new state
_onEnter: function() {
    this.timer = setTimeout( function() {
        this.handle( "timeout" );
    }.bind( this ), 30000 );
    this.<span class="apidocCodeKeywordSpan">emit</span>( "vehicles", { status: "GREEN" } );
},
// If all you need to do is transition to a new state
// inside an input handler, you can provide the string
// name of the state in place of the input handler function.
timeout: "green-interruptible",
pedestrianWaiting: function() {
    this.deferUntilTransition( "green-interruptible" );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.machina_OLD.off" id="apidoc.element.machina.machina_OLD.off">
        function <span class="apidocSignatureSpan">machina.machina_OLD.</span>off
        <span class="apidocSignatureSpan">( eventName, callback )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function ( eventName, callback ) {
		this.eventListeners = this.eventListeners || { "*": [] };
		if ( !eventName ) {
			this.eventListeners = {};
		} else {
			if ( callback ) {
				this.eventListeners[ eventName ] = _.without( this.eventListeners[ eventName ], callback );
			} else {
				this.eventListeners[ eventName ] = [];
			}
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Unsubscribing can be done a couple of ways:

```javascript
//each listener gets a return value
var sub = trafficLight.on("transition", someCallback);
sub.<span class="apidocCodeKeywordSpan">off</span>(); // unsubscribes the handler

// OR, we can use the FSM's prototype method -
// remove this specific subscription:
trafficLight.off("transition", someCallback);
// remove all transition subscribers
trafficLight.off("transition");
// remove ALL subscribers, period:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.machina_OLD.on" id="apidoc.element.machina.machina_OLD.on">
        function <span class="apidocSignatureSpan">machina.machina_OLD.</span>on
        <span class="apidocSignatureSpan">( eventName, callback )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function ( eventName, callback ) {
		var self = this;
		self.eventListeners = self.eventListeners || { "*": [] };
		if ( !self.eventListeners[ eventName ] ) {
			self.eventListeners[ eventName ] = [];
		}
		self.eventListeners[ eventName ].push( callback );
		return {
			eventName: eventName,
			callback: callback,
			off: function() {
				self.off( eventName, callback );
			}
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### And You Mentioned Events?
machina FSMs are event emitters, and subscribing to them is pretty easy:

```javascript

// I'd like to know when the transition event occurs
trafficLight.<span class="apidocCodeKeywordSpan">on</span>("transition", function (data){
    console.log("we just transitioned from " + data.fromState + " to " + data.toState);
});

// Or, maybe I want to know when ANY event occurs
trafficLight.on("*", function (eventName, data){
    console.log("this thing happened:", eventName);
});
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.off" id="apidoc.module.machina.off">module machina.off</a></h1>


    <h2>
        <a href="#apidoc.element.machina.off.off" id="apidoc.element.machina.off.off">
        function <span class="apidocSignatureSpan">machina.</span>off
        <span class="apidocSignatureSpan">( eventName, callback )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function ( eventName, callback ) {
				this.eventListeners = this.eventListeners || { "*": [] };
				if ( !eventName ) {
					this.eventListeners = {};
				} else {
					if ( callback ) {
						this.eventListeners[ eventName ] = _.without( this.eventListeners[ eventName ], callback );
					} else {
						this.eventListeners[ eventName ] = [];
					}
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Unsubscribing can be done a couple of ways:

```javascript
//each listener gets a return value
var sub = trafficLight.on("transition", someCallback);
sub.<span class="apidocCodeKeywordSpan">off</span>(); // unsubscribes the handler

// OR, we can use the FSM's prototype method -
// remove this specific subscription:
trafficLight.off("transition", someCallback);
// remove all transition subscribers
trafficLight.off("transition");
// remove ALL subscribers, period:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.on" id="apidoc.module.machina.on">module machina.on</a></h1>


    <h2>
        <a href="#apidoc.element.machina.on.on" id="apidoc.element.machina.on.on">
        function <span class="apidocSignatureSpan">machina.</span>on
        <span class="apidocSignatureSpan">( eventName, callback )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function ( eventName, callback ) {
				var self = this;
				self.eventListeners = self.eventListeners || { "*": [] };
				if ( !self.eventListeners[ eventName ] ) {
					self.eventListeners[ eventName ] = [];
				}
				self.eventListeners[ eventName ].push( callback );
				return {
					eventName: eventName,
					callback: callback,
					off: function() {
						self.off( eventName, callback );
					}
				};
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### And You Mentioned Events?
machina FSMs are event emitters, and subscribing to them is pretty easy:

```javascript

// I'd like to know when the transition event occurs
trafficLight.<span class="apidocCodeKeywordSpan">on</span>("transition", function (data){
    console.log("we just transitioned from " + data.fromState + " to " + data.toState);
});

// Or, maybe I want to know when ANY event occurs
trafficLight.on("*", function (eventName, data){
    console.log("this thing happened:", eventName);
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.utils" id="apidoc.module.machina.utils">module machina.utils</a></h1>


    <h2>
        <a href="#apidoc.element.machina.utils.createUUID" id="apidoc.element.machina.utils.createUUID">
        function <span class="apidocSignatureSpan">machina.utils.</span>createUUID
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createUUID() {
		var s = [];
		var hexDigits = "0123456789abcdef";
		for ( var i = 0; i &lt; 36; i++ ) {
			s[ i ] = hexDigits.substr( Math.floor( Math.random() * 0x10 ), 1 );
		}
		s[ 14 ] = "4"; // bits 12-15 of the time_hi_and_version field to 0010
		<span class="apidocCodeCommentSpan">/* jshint ignore:start */
</span>		s[ 19 ] = hexDigits.substr( ( s[ 19 ] &amp; 0x3 ) | 0x8, 1 ); // bits 6-7 of the clock_seq_hi_and_reserved to 01
		/* jshint ignore:end */
		s[ 8 ] = s[ 13 ] = s[ 18 ] = s[ 23 ] = "-";
		return s.join( "" );
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		var isCatchAll = false;
		var child;
		var result;
		var action;
		if ( !clientMeta.inExitHandler ) {
			child = stateObj._child &amp;&amp; stateObj._child.instance;
			if ( child &amp;&amp; !this.pendingDelegations[ inputDef.ticket ] &amp;&amp; !inputDef.bubbling ) {
				inputDef.ticket = ( inputDef.ticket || utils.<span class="apidocCodeKeywordSpan">createUUID</span>() );
				inputDef.delegated = true;
				this.pendingDelegations[ inputDef.ticket ] = { delegatedTo: child.namespace };
				// WARNING - returning a value from `handle` on child FSMs is not really supported.
				// If you need to return values from child FSM input handlers, use events instead.
				result = child.handle.apply( child, args );
			} else {
				if ( inputDef.ticket &amp;&amp; this.pendingDelegations[ inputDef.ticket ] ) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.utils.extend" id="apidoc.element.machina.utils.extend">
        function <span class="apidocSignatureSpan">machina.utils.</span>extend
        <span class="apidocSignatureSpan">( protoProps, staticProps )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function ( protoProps, staticProps ) {
		var parent = this;
		var fsm; // placeholder for instance constructor
		var machObj = {}; // object used to hold initialState &amp; states from prototype for instance-level merging
		var Ctor = function() {}; // placeholder ctor function used to insert level in prototype chain
	
		// The constructor function for the new subclass is either defined by you
		// (the "constructor" property in your `extend` definition), or defaulted
		// by us to simply call the parent's constructor.
		if ( protoProps &amp;&amp; protoProps.hasOwnProperty( "constructor" ) ) {
			fsm = protoProps.constructor;
		} else {
			// The default machina constructor (when using inheritance) creates a
			// deep copy of the states/initialState values from the prototype and
			// extends them over the instance so that they'll be instance-level.
			// If an options arg (args[0]) is passed in, a states or intialState
			// value will be preferred over any data pulled up from the prototype.
			fsm = function() {
				var args = slice.call( arguments, 0 );
				args[ 0 ] = args[ 0 ] || {};
				var blendedState;
				var instanceStates = args[ 0 ].states || {};
				blendedState = _.merge( _.cloneDeep( machObj ), { states: instanceStates } );
				blendedState.initialState = args[ 0 ].initialState || this.initialState;
				_.extend( args[ 0 ], blendedState );
				parent.apply( this, args );
			};
		}
	
		// Inherit class (static) properties from parent.
		_.merge( fsm, parent );
	
		// Set the prototype chain to inherit from `parent`, without calling
		// `parent`'s constructor function.
		Ctor.prototype = parent.prototype;
		fsm.prototype = new Ctor();
	
		// Add prototype properties (instance properties) to the subclass,
		// if supplied.
		if ( protoProps ) {
			_.extend( fsm.prototype, protoProps );
			_.merge( machObj, _.transform( protoProps, function( accum, val, key ) {
				if ( _machKeys.indexOf( key ) !== -1 ) {
					accum[ key ] = val;
				}
			} ) );
		}
	
		// Add static properties to the constructor function, if supplied.
		if ( staticProps ) {
			_.merge( fsm, staticProps );
		}
	
		// Correctly set child's `prototype.constructor`.
		fsm.prototype.constructor = fsm;
	
		// Set a convenience property in case the parent's prototype is needed later.
		fsm.__super__ = parent.prototype;
		return fsm;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Quick Example

First - you need to include it in your environment (browser, node, etc.):

```javascript
// If you're not using an AMD loader, machina is available on the window
// Just make sure you have lodash loaded before machina
var MyFsm = machina.Fsm.<span class="apidocCodeKeywordSpan">extend</span>({ /* your stuff */});

// If you're using an AMD loader:
require(['machina'], function(machina){
    return machina.Fsm.extend({ /* your stuff */});
});

// node.js/CommonJS:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.utils.getChildFsmInstance" id="apidoc.element.machina.utils.getChildFsmInstance">
        function <span class="apidocSignatureSpan">machina.utils.</span>getChildFsmInstance
        <span class="apidocSignatureSpan">( config )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getChildFsmInstance( config ) {
		if ( !config ) {
			return;
		}
		var childFsmDefinition = {};
		if ( typeof config === "object" ) {
			// is this a config object with a factory?
			if ( config.factory ) {
				childFsmDefinition = config;
				childFsmDefinition.instance = childFsmDefinition.factory();
			} else {
				// assuming this is a machina instance
				childFsmDefinition.factory = function() {
					return config;
				};
			}
		} else if ( typeof config === "function" ) {
			childFsmDefinition.factory = config;
		}
		childFsmDefinition.instance = childFsmDefinition.factory();
		return childFsmDefinition;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.utils.getDefaultBehavioralOptions" id="apidoc.element.machina.utils.getDefaultBehavioralOptions">
        function <span class="apidocSignatureSpan">machina.utils.</span>getDefaultBehavioralOptions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultBehavioralOptions() {
		return {
			initialState: "uninitialized",
			eventListeners: {
				"*": []
			},
			states: {},
			namespace: makeFsmNamespace(),
			useSafeEmit: false,
			hierarchy: {},
			pendingDelegations: {}
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.utils.getDefaultClientMeta" id="apidoc.element.machina.utils.getDefaultClientMeta">
        function <span class="apidocSignatureSpan">machina.utils.</span>getDefaultClientMeta
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultClientMeta() {
		return {
			inputQueue: [],
			targetReplayState: "",
			state: undefined,
			priorState: undefined,
			priorAction: "",
			currentAction: "",
			currentActionArgs: undefined,
			inExitHandler: false
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	ensureClientMeta: function ensureClientMeta( client ) {
		if ( typeof client !== "object" ) {
			throw new Error( "An FSM client must be an object." );
		}
		client[ MACHINA_PROP ] = client[ MACHINA_PROP ] || {};
		if ( !client[ MACHINA_PROP ][ this.namespace ] ) {
			client[ MACHINA_PROP ][ this.namespace ] = _.cloneDeep( utils.<span class="apidocCodeKeywordSpan">getDefaultClientMeta</span>() );
			this.initClient( client );
		}
		return client[ MACHINA_PROP ][ this.namespace ];
	},

	buildEventPayload: function( client, data ) {
		if ( _.isPlainObject( data ) ) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.utils.getDefaultOptions" id="apidoc.element.machina.utils.getDefaultOptions">
        function <span class="apidocSignatureSpan">machina.utils.</span>getDefaultOptions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultBehavioralOptions() {
		return {
			initialState: "uninitialized",
			eventListeners: {
				"*": []
			},
			states: {},
			namespace: makeFsmNamespace(),
			useSafeEmit: false,
			hierarchy: {},
			pendingDelegations: {}
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.utils.getLeaklessArgs" id="apidoc.element.machina.utils.getLeaklessArgs">
        function <span class="apidocSignatureSpan">machina.utils.</span>getLeaklessArgs
        <span class="apidocSignatureSpan">( args, startIdx )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLeaklessArgs( args, startIdx ) {
		var result = [];
		for ( var i = ( startIdx || 0 ); i &lt; args.length; i++ ) {
			result[ i ] = args[ i ];
		}
		return result;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		}
		return isCatchAll ?
			_args.slice( 1 ) :
			_args.slice( 2 );
	},
	// "classic" machina FSM do not emit the client property on events (which would be the FSM itself)
	buildEventPayload: function() {
		var args = this.ensureClientArg( utils.<span class="apidocCodeKeywordSpan">getLeaklessArgs</span>( arguments ) );
		var data = args[ 1 ];
		if ( _.isPlainObject( data ) ) {
			return _.extend( data, { namespace: this.namespace } );
		} else {
			return { data: data || null, namespace: this.namespace };
		}
	}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.utils.listenToChild" id="apidoc.element.machina.utils.listenToChild">
        function <span class="apidocSignatureSpan">machina.utils.</span>listenToChild
        <span class="apidocSignatureSpan">( fsm, child )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenToChild( fsm, child ) {
		// Need to investigate potential for discarded event
		// listener memory leak in long-running, deeply-nested hierarchies.
		return child.on( "*", function( eventName, data ) {
			switch ( eventName ) {
				case events.NO_HANDLER:
					if ( !data.ticket &amp;&amp; !data.delegated &amp;&amp; data.namespace !== fsm.namespace ) {
						// Ok - we're dealing w/ a child handling input that should bubble up
						data.args[ 1 ].bubbling = true;
					}
					// we do NOT bubble _reset inputs up to the parent
					if ( data.inputType !== "_reset" ) {
						fsm.handle.apply( fsm, data.args );
					}
					break;
				case events.HANDLING :
					var ticket = data.ticket;
					if ( ticket &amp;&amp; fsm.pendingDelegations[ ticket ] ) {
						delete fsm.pendingDelegations[ ticket ];
					}
					fsm.emit( eventName, data ); // possibly transform payload?
					break;
				default:
					fsm.emit( eventName, data ); // possibly transform payload?
					break;
			}
		} );
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				if ( curStateObj &amp;&amp; curStateObj._child &amp;&amp; curStateObj._child.instance &amp;&amp; this.hierarchy[ curStateObj
._child.instance.namespace ] ) {
					this.hierarchy[ curStateObj._child.instance.namespace ].off();
				}
				clientMeta.targetReplayState = newState;
				clientMeta.priorState = curState;
				clientMeta.state = newState;
				if ( child ) {
					this.hierarchy[ child.namespace ] = utils.<span class="apidocCodeKeywordSpan">listenToChild</span>( this, child );
				}
				var eventPayload = this.buildEventPayload( client, {
					fromState: clientMeta.priorState,
					action: clientMeta.currentAction,
					toState: newState
				} );
				this.emit( TRANSITION, eventPayload );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machina.utils.makeFsmNamespace" id="apidoc.element.machina.utils.makeFsmNamespace">
        function <span class="apidocSignatureSpan">machina.utils.</span>makeFsmNamespace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeFsmNamespace = function () {
			return "fsm." + machinaCount++;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function getDefaultBehavioralOptions() {
	return {
		initialState: "uninitialized",
		eventListeners: {
			"*": []
		},
		states: {},
		namespace: utils.<span class="apidocCodeKeywordSpan">makeFsmNamespace</span>(),
		useSafeEmit: false,
		hierarchy: {},
		pendingDelegations: {}
	};
}

function getDefaultClientMeta() {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.utils.createUUID" id="apidoc.module.machina.utils.createUUID">module machina.utils.createUUID</a></h1>


    <h2>
        <a href="#apidoc.element.machina.utils.createUUID.createUUID" id="apidoc.element.machina.utils.createUUID.createUUID">
        function <span class="apidocSignatureSpan">machina.utils.</span>createUUID
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createUUID() {
		var s = [];
		var hexDigits = "0123456789abcdef";
		for ( var i = 0; i &lt; 36; i++ ) {
			s[ i ] = hexDigits.substr( Math.floor( Math.random() * 0x10 ), 1 );
		}
		s[ 14 ] = "4"; // bits 12-15 of the time_hi_and_version field to 0010
		<span class="apidocCodeCommentSpan">/* jshint ignore:start */
</span>		s[ 19 ] = hexDigits.substr( ( s[ 19 ] &amp; 0x3 ) | 0x8, 1 ); // bits 6-7 of the clock_seq_hi_and_reserved to 01
		/* jshint ignore:end */
		s[ 8 ] = s[ 13 ] = s[ 18 ] = s[ 23 ] = "-";
		return s.join( "" );
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		var isCatchAll = false;
		var child;
		var result;
		var action;
		if ( !clientMeta.inExitHandler ) {
			child = stateObj._child &amp;&amp; stateObj._child.instance;
			if ( child &amp;&amp; !this.pendingDelegations[ inputDef.ticket ] &amp;&amp; !inputDef.bubbling ) {
				inputDef.ticket = ( inputDef.ticket || utils.<span class="apidocCodeKeywordSpan">createUUID</span>() );
				inputDef.delegated = true;
				this.pendingDelegations[ inputDef.ticket ] = { delegatedTo: child.namespace };
				// WARNING - returning a value from `handle` on child FSMs is not really supported.
				// If you need to return values from child FSM input handlers, use events instead.
				result = child.handle.apply( child, args );
			} else {
				if ( inputDef.ticket &amp;&amp; this.pendingDelegations[ inputDef.ticket ] ) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.utils.getChildFsmInstance" id="apidoc.module.machina.utils.getChildFsmInstance">module machina.utils.getChildFsmInstance</a></h1>


    <h2>
        <a href="#apidoc.element.machina.utils.getChildFsmInstance.getChildFsmInstance" id="apidoc.element.machina.utils.getChildFsmInstance.getChildFsmInstance">
        function <span class="apidocSignatureSpan">machina.utils.</span>getChildFsmInstance
        <span class="apidocSignatureSpan">( config )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getChildFsmInstance( config ) {
		if ( !config ) {
			return;
		}
		var childFsmDefinition = {};
		if ( typeof config === "object" ) {
			// is this a config object with a factory?
			if ( config.factory ) {
				childFsmDefinition = config;
				childFsmDefinition.instance = childFsmDefinition.factory();
			} else {
				// assuming this is a machina instance
				childFsmDefinition.factory = function() {
					return config;
				};
			}
		} else if ( typeof config === "function" ) {
			childFsmDefinition.factory = config;
		}
		childFsmDefinition.instance = childFsmDefinition.factory();
		return childFsmDefinition;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.utils.getDefaultBehavioralOptions" id="apidoc.module.machina.utils.getDefaultBehavioralOptions">module machina.utils.getDefaultBehavioralOptions</a></h1>


    <h2>
        <a href="#apidoc.element.machina.utils.getDefaultBehavioralOptions.getDefaultBehavioralOptions" id="apidoc.element.machina.utils.getDefaultBehavioralOptions.getDefaultBehavioralOptions">
        function <span class="apidocSignatureSpan">machina.utils.</span>getDefaultBehavioralOptions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultBehavioralOptions() {
		return {
			initialState: "uninitialized",
			eventListeners: {
				"*": []
			},
			states: {},
			namespace: makeFsmNamespace(),
			useSafeEmit: false,
			hierarchy: {},
			pendingDelegations: {}
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.utils.getDefaultClientMeta" id="apidoc.module.machina.utils.getDefaultClientMeta">module machina.utils.getDefaultClientMeta</a></h1>


    <h2>
        <a href="#apidoc.element.machina.utils.getDefaultClientMeta.getDefaultClientMeta" id="apidoc.element.machina.utils.getDefaultClientMeta.getDefaultClientMeta">
        function <span class="apidocSignatureSpan">machina.utils.</span>getDefaultClientMeta
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultClientMeta() {
		return {
			inputQueue: [],
			targetReplayState: "",
			state: undefined,
			priorState: undefined,
			priorAction: "",
			currentAction: "",
			currentActionArgs: undefined,
			inExitHandler: false
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	ensureClientMeta: function ensureClientMeta( client ) {
		if ( typeof client !== "object" ) {
			throw new Error( "An FSM client must be an object." );
		}
		client[ MACHINA_PROP ] = client[ MACHINA_PROP ] || {};
		if ( !client[ MACHINA_PROP ][ this.namespace ] ) {
			client[ MACHINA_PROP ][ this.namespace ] = _.cloneDeep( utils.<span class="apidocCodeKeywordSpan">getDefaultClientMeta</span>() );
			this.initClient( client );
		}
		return client[ MACHINA_PROP ][ this.namespace ];
	},

	buildEventPayload: function( client, data ) {
		if ( _.isPlainObject( data ) ) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.utils.getLeaklessArgs" id="apidoc.module.machina.utils.getLeaklessArgs">module machina.utils.getLeaklessArgs</a></h1>


    <h2>
        <a href="#apidoc.element.machina.utils.getLeaklessArgs.getLeaklessArgs" id="apidoc.element.machina.utils.getLeaklessArgs.getLeaklessArgs">
        function <span class="apidocSignatureSpan">machina.utils.</span>getLeaklessArgs
        <span class="apidocSignatureSpan">( args, startIdx )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLeaklessArgs( args, startIdx ) {
		var result = [];
		for ( var i = ( startIdx || 0 ); i &lt; args.length; i++ ) {
			result[ i ] = args[ i ];
		}
		return result;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		}
		return isCatchAll ?
			_args.slice( 1 ) :
			_args.slice( 2 );
	},
	// "classic" machina FSM do not emit the client property on events (which would be the FSM itself)
	buildEventPayload: function() {
		var args = this.ensureClientArg( utils.<span class="apidocCodeKeywordSpan">getLeaklessArgs</span>( arguments ) );
		var data = args[ 1 ];
		if ( _.isPlainObject( data ) ) {
			return _.extend( data, { namespace: this.namespace } );
		} else {
			return { data: data || null, namespace: this.namespace };
		}
	}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.utils.listenToChild" id="apidoc.module.machina.utils.listenToChild">module machina.utils.listenToChild</a></h1>


    <h2>
        <a href="#apidoc.element.machina.utils.listenToChild.listenToChild" id="apidoc.element.machina.utils.listenToChild.listenToChild">
        function <span class="apidocSignatureSpan">machina.utils.</span>listenToChild
        <span class="apidocSignatureSpan">( fsm, child )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenToChild( fsm, child ) {
		// Need to investigate potential for discarded event
		// listener memory leak in long-running, deeply-nested hierarchies.
		return child.on( "*", function( eventName, data ) {
			switch ( eventName ) {
				case events.NO_HANDLER:
					if ( !data.ticket &amp;&amp; !data.delegated &amp;&amp; data.namespace !== fsm.namespace ) {
						// Ok - we're dealing w/ a child handling input that should bubble up
						data.args[ 1 ].bubbling = true;
					}
					// we do NOT bubble _reset inputs up to the parent
					if ( data.inputType !== "_reset" ) {
						fsm.handle.apply( fsm, data.args );
					}
					break;
				case events.HANDLING :
					var ticket = data.ticket;
					if ( ticket &amp;&amp; fsm.pendingDelegations[ ticket ] ) {
						delete fsm.pendingDelegations[ ticket ];
					}
					fsm.emit( eventName, data ); // possibly transform payload?
					break;
				default:
					fsm.emit( eventName, data ); // possibly transform payload?
					break;
			}
		} );
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				if ( curStateObj &amp;&amp; curStateObj._child &amp;&amp; curStateObj._child.instance &amp;&amp; this.hierarchy[ curStateObj
._child.instance.namespace ] ) {
					this.hierarchy[ curStateObj._child.instance.namespace ].off();
				}
				clientMeta.targetReplayState = newState;
				clientMeta.priorState = curState;
				clientMeta.state = newState;
				if ( child ) {
					this.hierarchy[ child.namespace ] = utils.<span class="apidocCodeKeywordSpan">listenToChild</span>( this, child );
				}
				var eventPayload = this.buildEventPayload( client, {
					fromState: clientMeta.priorState,
					action: clientMeta.currentAction,
					toState: newState
				} );
				this.emit( TRANSITION, eventPayload );
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machina.utils.makeFsmNamespace" id="apidoc.module.machina.utils.makeFsmNamespace">module machina.utils.makeFsmNamespace</a></h1>


    <h2>
        <a href="#apidoc.element.machina.utils.makeFsmNamespace.makeFsmNamespace" id="apidoc.element.machina.utils.makeFsmNamespace.makeFsmNamespace">
        function <span class="apidocSignatureSpan">machina.utils.</span>makeFsmNamespace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeFsmNamespace = function () {
			return "fsm." + machinaCount++;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function getDefaultBehavioralOptions() {
	return {
		initialState: "uninitialized",
		eventListeners: {
			"*": []
		},
		states: {},
		namespace: utils.<span class="apidocCodeKeywordSpan">makeFsmNamespace</span>(),
		useSafeEmit: false,
		hierarchy: {},
		pendingDelegations: {}
	};
}

function getDefaultClientMeta() {
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>